<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://panson.top</id>
    <title>Panson</title>
    <updated>2025-12-27T09:04:38.190Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://panson.top"/>
    <link rel="self" href="https://panson.top/atom.xml"/>
    <subtitle>清风拂山岗，明月照大江。</subtitle>
    <logo>https://panson.top/images/avatar.png</logo>
    <icon>https://panson.top/favicon.ico</icon>
    <rights>All rights reserved 2025, Panson</rights>
    <entry>
        <title type="html"><![CDATA[关于本站]]></title>
        <id>https://panson.top/post/zhi-ding-tie/</id>
        <link href="https://panson.top/post/zhi-ding-tie/">
        </link>
        <updated>2100-10-14T02:48:07.000Z</updated>
        <summary type="html"><![CDATA[<p><em>分享自己的所见所得，后端技术、供应链、任务调度（AI阅片任务调度、渲染任务调度）、摄影相关。</em></p>
<hr>
<h2 id="一-关于本站">一、关于本站</h2>
<ol>
<li>
<p>博客基于 Github + Gridea，由于众所周知的原因，科学上网后才能流畅阅读。</p>
</li>
<li>
<p>博客使用的 Featured Image 和正文首部插图来源: <a href="https://unsplash.com/">unsplash</a><br>
、<a href="https://film-grab.com/">FILMGRAB</a>、豆瓣、 <a href="https://screenmusings.org/">screenmusings</a>、<a href="https://www.ysjf.com/material">影视飓风</a>，大多数图片也需要科学上网才能正常加载。</p>
</li>
<li>
<p>当然，也有部分是我自己的“摄影作品”。</p>
</li>
</ol>
<h2 id="二-供应链">二、供应链</h2>
<p>目前做的是供应链领域的后端开发，看过一些书和资料，结合日常工作内容，写了一个小系列。<br>
具体可以看：<a href="https://panson.top/post/supply-chain/">https://panson.top/post/supply-chain/</a>，也在这个站点下。</p>
]]></summary>
        <content type="html"><![CDATA[<p><em>分享自己的所见所得，后端技术、供应链、任务调度（AI阅片任务调度、渲染任务调度）、摄影相关。</em></p>
<hr>
<h2 id="一-关于本站">一、关于本站</h2>
<ol>
<li>
<p>博客基于 Github + Gridea，由于众所周知的原因，科学上网后才能流畅阅读。</p>
</li>
<li>
<p>博客使用的 Featured Image 和正文首部插图来源: <a href="https://unsplash.com/">unsplash</a><br>
、<a href="https://film-grab.com/">FILMGRAB</a>、豆瓣、 <a href="https://screenmusings.org/">screenmusings</a>、<a href="https://www.ysjf.com/material">影视飓风</a>，大多数图片也需要科学上网才能正常加载。</p>
</li>
<li>
<p>当然，也有部分是我自己的“摄影作品”。</p>
</li>
</ol>
<h2 id="二-供应链">二、供应链</h2>
<p>目前做的是供应链领域的后端开发，看过一些书和资料，结合日常工作内容，写了一个小系列。<br>
具体可以看：<a href="https://panson.top/post/supply-chain/">https://panson.top/post/supply-chain/</a>，也在这个站点下。</p>
<!-- more -->
<h3 id="重构篇">重构篇</h3>
<ul>
<li><a href="https://panson.top/post/wes-jiagou-sheji-yu-chonggoushijian/">重构总集篇：十万字长文深度解析 WES 架构设计与重构实践</a></li>
<li><a href="https://panson.top/post/rocketmq-shi-wu-xiao-xi-yuan-ma-yue-du/">RocketMQ 事务消息源码阅读</a></li>
<li><a href="https://panson.top/post/rocketmq-shi-wu-shi-ru-he-shi-xian-de/">RocketMQ 事务是如何实现的？</a></li>
<li><a href="https://panson.top/post/fen-bu-shi-shi-wu-zhi-saga/">分布式事务之 Saga</a></li>
<li><a href="https://panson.top/post/fen-bu-shi-shi-wu-zhi-tcc/">分布式事务之 TCC</a></li>
<li><a href="https://panson.top/post/fen-bu-shi-shi-wu-zhi-xa-xie-yi/">分布式事务之 XA 协议</a></li>
<li><a href="https://panson.top/post/01ding-dan-hao-zuo-ye-dan-hao-ren-wu-hao-ru-he-she-ji/">订单号、作业单号、任务号如何设计?</a></li>
<li><a href="https://panson.top/post/wei-shi-me-yao-she-ji-yi-ge-shu-ju-yi-zhi-xing-zu-jian-md/">为什么要设计一个数据一致性组件</a></li>
<li><a href="https://panson.top/post/shi-me-shi-ben-di-xiao-xi-biao/">什么是本地消息表？</a></li>
<li><a href="https://panson.top/post/ru-he-she-ji-ben-di-xiao-xi-biao/">如何设计本地消息表？</a></li>
<li><a href="https://panson.top/post/shu-ju-yi-zhi-xing-zu-jian-zhi-ren-wu-mo-xing/">数据一致性组件之任务模型</a></li>
<li><a href="https://panson.top/post/shu-ju-yi-zhi-xing-zu-jian-zhi-zi-ding-yi-starter/">数据一致性组件之自定义 Starter</a></li>
<li><a href="https://panson.top/post/wes-chong-gou-xi-lie-yi-ji-lu-yi-xia-wes-chong-gou-li-shi/">WES 重构系列（一）：记录一下 WES 重构历史</a></li>
<li><a href="https://panson.top/post/wes-chong-gou-xi-lie-er-ling-yu-hua-fen-zhi-li-huo-ye-wu-shang-fu/">WES 重构系列（二）：领域划分之理货业务上浮</a></li>
<li><a href="https://panson.top/post/wes-chong-gou-xi-lie-san-he-bing-xi-tong-zhi-chi-hun-chang-ye-wu/">WES 重构系列（三）：系统融合支持混场业务调度</a></li>
<li><a href="https://panson.top/post/wes-chong-gou-xi-lie-si-chu-ku-diao-du-lian-lu-shu-li/">WES 重构系列（四）：出库调度正向链路梳理</a></li>
<li><a href="https://panson.top/post/wes-chong-gou-xi-lie-wu-chu-ku-diao-du-zheng-xiang-lian-lu-xiao-lu-you-hua/">WES 重构系列（五）：出库调度正向链路效率优化</a></li>
<li><a href="https://panson.top/post/wes-chong-gou-xi-lie-liu-lao-jiu-xi-tong-chi-xu-you-hua/">WES 重构系列（六）：老旧系统的持续性改造</a></li>
<li><a href="https://panson.top/post/wes-chong-gou-xi-lie-qi-guan-yu-wes-shu-ju-zui-zhong-yi-zhi-xing-zu-jian-de-si-kao/">WES 重构系列（七）：关于WES 数据最终一致性组件的思考</a></li>
<li><a href="https://panson.top/post/wes-chong-gou-xi-lie-ba-wes-san-ji-ku-cun-mo-xing/">WES 重构系列（八）：WES 三级库存模型</a></li>
<li><a href="https://panson.top/post/wes-chong-gou-xi-lie-jiu-ru-he-ying-dui-fu-za-ye-wu-xi-tong-gui-ze/">WES 重构系列（九）：如何应对复杂业务系统规则</a></li>
<li><a href="https://panson.top/post/wes-chong-gou-xi-lie-shi-liao-liao-wes-dan-ju-ren-wu-diao-du/">WES 重构系列（十）：聊聊 WES 单据任务调度</a></li>
<li><a href="https://panson.top/post/wes-chong-gou-xi-lie-shi-yi-chu-ku-lian-lu-zhong-de-fen-bu-shi-shi-wu-saga-shi-jian/">WES 重构系列（十一）：出库链路中的分布式事务 Saga 实践</a></li>
</ul>
<h3 id="线上问题篇">线上问题篇</h3>
<ul>
<li><a href="https://panson.top/post/yi-ci-jvm-shen-you-hua-dao-zhi-de-ri-zhi-diu-shi-wen-ti/">一次 JVM “神优化” 导致的日志丢失问题</a></li>
<li><a href="https://panson.top/post/yi-ci-xian-shang-mysql-suo-chao-shi-wen-ti-ji-lu/">一次线上 MySQL 锁超时问题记录</a></li>
<li><a href="https://panson.top/post/yi-ci-shang-you-geng-gai-jie-kou-dao-zhi-de-bai-wan-ji-shu-ju-sao-miao-yin-qi-de-dang-ji-wen-ti-md/">一次上游更改接口导致的百万级数据扫描引起的宕机问题.md</a></li>
<li><a href="https://panson.top/post/yi-ci-xian-shang-mysql-si-suo-wen-ti-ji-lu/">一次线上 MySQL 死锁问题记录</a></li>
<li><a href="https://panson.top/post/yi-ci-xian-shang-ren-wu-dao-zhan-bu-dan-shi-cao-wen-ti/">一次线上小车调度到站不弹实操问题</a></li>
<li><a href="">todo: 一次夜间数据归档引起的 RocketMQ busy 问题</a></li>
<li><a href="">todo: 一次老旧系统 Docker kill JVM 问题</a></li>
<li><a href="">todo: 一次一级库存引起的锁问题</a></li>
<li><a href="">todo: 单号生成死锁问题</a></li>
<li><a href="">todo: 数据库 ABA 导致任务不调度问题</a></li>
</ul>
<h3 id="业务篇">业务篇</h3>
<ul>
<li>
<p><a href="https://panson.top/post/gong-ying-lian-xi-tong/">开篇：供应链及其子系统</a></p>
</li>
<li>
<p><a href="https://panson.top/post/001_-shi-me-shi-ru-ku-dan/">001_什么是入库单</a></p>
</li>
<li>
<p><a href="https://panson.top/post/002_-shi-me-shi-ru-ku/">002_什么是入库</a></p>
</li>
<li>
<p><a href="https://panson.top/post/003_-shi-me-shi-chu-ku-dan/">003_什么是出库单</a></p>
</li>
<li>
<p><a href="https://panson.top/post/004_-shi-me-shi-chu-ku/">004_什么是出库</a></p>
</li>
<li>
<p><a href="https://panson.top/post/005_-shi-me-shi-shang-pin-rong-liang/">005_什么是商品容量</a></p>
</li>
<li>
<p><a href="https://panson.top/post/006_-shi-me-shi-shang-pin-tiao-ma/">006_什么是商品条码</a></p>
</li>
<li>
<p><a href="https://panson.top/post/007_-shi-me-shi-shang-pin/">007_什么是商品</a></p>
</li>
<li>
<p><a href="https://panson.top/post/008_-shi-me-shi-liao-xiang-rong-qi/">008_什么是料箱容器</a></p>
</li>
<li>
<p><a href="https://panson.top/post/009_-shi-me-shi-gong-zuo-zhan/">009_什么是工作站</a></p>
</li>
<li>
<p><a href="https://panson.top/post/010_-shi-me-shi-ku-cun/">010_什么是库存</a></p>
</li>
<li>
<p><a href="https://panson.top/post/011_-shi-me-shi-pi-ci/">011_什么是批次</a></p>
</li>
<li>
<p><a href="https://panson.top/post/012_-shi-me-shi-liao-ge-dian-zi-biao-qian/">012_什么是料格电子标签</a></p>
</li>
<li>
<p><a href="https://panson.top/post/013_-shi-me-shi-zhi-neng-cang-chu/">013_什么是智能仓储</a></p>
</li>
<li>
<p><a href="https://panson.top/post/014_-shi-me-shi-li-huo-dan/">014_什么是理货单</a></p>
</li>
<li>
<p><a href="https://panson.top/post/015_-shi-me-shi-li-huo/">015_什么是理货</a></p>
</li>
<li>
<p><a href="https://panson.top/post/016_-shi-me-shi-pan-dian-dan/">016_什么是盘点单</a></p>
</li>
<li>
<p><a href="https://panson.top/post/017_-shi-me-shi-pan-dian/">017_什么是盘点</a></p>
</li>
<li>
<p><a href="https://panson.top/post/018_-shi-me-shi-huo-zhu/">018_什么是货主</a></p>
</li>
<li>
<p><a href="https://panson.top/post/019_-shi-me-shi-zu-xiang/">019_什么是组箱</a></p>
</li>
<li>
<p><a href="https://panson.top/post/020_-shi-me-shi-qu-xiao-zu-xiang/">020_什么是取消组箱</a></p>
</li>
<li>
<p><a href="https://panson.top/post/021_-shi-me-shi-pda/">021_什么是 PDA</a></p>
</li>
<li>
<p><a href="https://panson.top/post/022_-shi-me-shi-huo-jia-dao-ren-chi-xian-zhi-jie-shang-jia/">022_什么是货架到人离线直接上架</a></p>
</li>
<li>
<p><a href="https://panson.top/post/023_-shi-me-shi-huo-jia-dao-ren-chi-xian-zheng-tuo-shang-jia/">023_什么是货架到人离线整托上架</a></p>
</li>
<li>
<p><a href="https://panson.top/post/024_-shi-me-shi-ku-cun-diao-zheng-dan/">024_什么是库存调整单</a></p>
</li>
<li>
<p><a href="https://panson.top/post/025_-shi-me-shi-pi-ci-diao-zheng-dan/">025_什么是批次调整单</a></p>
</li>
<li>
<p><a href="https://panson.top/post/026_-shi-me-shi-huo-quan-diao-zheng-dan/">026_什么是货权调整单</a></p>
</li>
<li>
<p><a href="https://panson.top/post/027_-shi-me-shi-ji-he-dan/">027_什么是集合单</a></p>
</li>
<li>
<p><a href="https://panson.top/post/028_-shi-me-shi-liao-xiang-dao-ren/">028_什么是料箱到人</a></p>
</li>
<li>
<p><a href="https://panson.top/post/029_-shi-me-shi-huo-jia-dao-ren/">029_什么是货架到人</a></p>
</li>
<li>
<p><a href="https://panson.top/post/030_-huo-jia-dao-ren-he-liao-xiang-dao-ren-de-qu-bie/">030_货架到人和料箱到人的区别</a></p>
</li>
<li>
<p><a href="https://panson.top/post/031_-shi-me-shi-liao-xiang-dao-ren-zheng-xiang-zhi-jie-shang-jia/">031_什么是料箱到人整箱直接上架</a></p>
</li>
<li>
<p><a href="https://panson.top/post/032_-shi-me-shi-liao-xiang-dao-ren-kong-xiang-zhi-jie-shang-jia/">032_什么是料箱到人空箱直接上架</a></p>
</li>
<li>
<p><a href="https://panson.top/post/033_-shi-me-shi-liao-xiang-dao-ren-zai-xian-zhi-dao-shang-jia/">033_什么是料箱到人在线指导上架</a></p>
</li>
<li>
<p><a href="https://panson.top/post/034_-shi-me-shi-huo-jia-dao-ren-zai-xian-zhi-jie-shang-jia/">034_什么是货架到人在线直接上架</a></p>
</li>
<li>
<p><a href="https://panson.top/post/035_-shi-me-shi-huo-jia-dao-ren-an-dan-zhi-dao-shang-jia/">035_什么是货架到人按单指导上架</a></p>
</li>
<li>
<p><a href="https://panson.top/post/036_-shi-me-shi-liao-xiang-dao-ren-zai-xian-jian-xuan/">036_什么是料箱到人在线拣选</a></p>
</li>
<li>
<p><a href="https://panson.top/post/037_-shi-me-shi-huo-jia-dao-ren-zai-xian-jian-xuan/">037_什么是货架到人在线拣选</a></p>
</li>
<li>
<p><a href="https://panson.top/post/038_-shi-me-shi-liao-xiang-dao-ren-kong-xiang-chu-ku/">038_什么是料箱到人空箱出库</a></p>
</li>
<li>
<p><a href="https://panson.top/post/039_-shi-me-shi-liao-xiang-dao-ren-zai-xian-pan-dian/">039_什么是料箱到人在线盘点</a></p>
</li>
<li>
<p><a href="https://panson.top/post/040_-shi-me-shi-huo-jia-dao-ren-zai-xian-pan-dian/">040_什么是货架到人在线盘点</a></p>
</li>
<li>
<p><a href="https://panson.top/post/041_-shi-me-shi-fu-pan-dan/">041_什么是复盘单</a></p>
</li>
<li>
<p><a href="https://panson.top/post/042_-shi-me-shi-liao-xiang-dao-ren-zai-xian-li-huo/">042_什么是料箱到人在线理货</a></p>
</li>
<li>
<p><a href="https://panson.top/post/043_-shi-me-shi-huo-jia-dao-ren-zai-xian-li-huo/">043_什么是货架到人在线理货</a></p>
</li>
<li>
<p><a href="https://panson.top/post/044shi-me-shi-ku-qu/">044.什么是库区</a></p>
</li>
<li>
<p><a href="https://panson.top/post/045shi-me-shi-huo-jia-yu-ku-wei/">045.什么是货架与库位</a></p>
</li>
<li>
<p><a href="https://panson.top/post/046shi-me-shi-agv/">046.什么是 AGV</a></p>
</li>
<li>
<p><a href="https://panson.top/post/047shi-me-shi-zuo-ye-di-tu/">047.什么是作业地图</a></p>
</li>
<li>
<p><a href="https://panson.top/post/048shi-me-shi-shang-pin-re-du/">048.什么是商品热度</a></p>
</li>
<li>
<p><a href="https://panson.top/post/049shi-me-shi-re-du-yi-wei/">049.什么是热度移位</a></p>
</li>
<li>
<p><a href="https://panson.top/post/050shi-me-shi-que-jian/">050.什么是缺拣</a></p>
</li>
<li>
<p>……</p>
<h2 id="三-任务调度">三、任务调度</h2>
<p>更早之前的两份工作内容都和任务调度有关，主要是关于 AI 任务调度和渲染任务调度。当然这种“任务”</p>
</li>
</ul>
<!-- more -->
<p>和后端开发中的任务调度框架不太一样，类似 XXL-JOB 这种，我一般理解为定时任务，不带业务属性，但之前做的 AI 任务调度和渲染任务调度则更偏向于业务。下面简单介绍一下我参与做过的内容（其实本来应该写一个开源脚手架的，最近沉迷摄影，一直没时间去回想这些东西，时间过去有点久了，细节忘记了~提醒我及时记录）。</p>
<h3 id="1-ai-任务调度系统">1. AI 任务调度系统</h3>
<p>属于医疗领域，核心是为了将医院、体检机构拍摄的片子，借助 AI 智能阅片，并输出诊断结果，辅助治疗。</p>
<ul>
<li>数据来源：体检机构、大中小医院的片子</li>
<li>文件系统：上传的片子预处理，存储文件、预处理的数据</li>
<li>任务调度系统：
<ul>
<li>Master 将处理好的片子，做任务分发到各个 Slave 机器上</li>
<li>Slave 上的算法服务会将任务做AI 分析，存储分析结果</li>
</ul>
</li>
<li>其他的还有阅片系统、SSO 平台、前置机之类的，还有单机平台、一体机之类的，非调度核心系统。</li>
</ul>
<h3 id="2-渲染任务调度">2. 渲染任务调度</h3>
<p>核心逻辑其实与上面讲的差不多，不过业务逻辑更加复杂，链路也更加长一些，数据量的话日均有千万级别。<br>
负责的东西主要包括以下几个部分：</p>
<ul>
<li>渲染弹窗相关：渲染配置、分辨率体系、渲染券相关</li>
<li>中台相关业务：国际版 CooHom、灯光动画、遮罩渲染相关能力的开发、对象存储迁移（阿里OSS -&gt; 腾讯 COS）等等</li>
<li>渲染任务回归平台的开发</li>
</ul>
<h2 id="四-摄影">四、摄影</h2>
<p>单独建了一个网站，买了 10 年的域名：www.timelesslens.site。<br>
<img src="https://raw.githubusercontent.com/PansonPanson/blog-pic-2023/main/2023/202311291106687.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[大模型自学笔记]]></title>
        <id>https://panson.top/post/da-mo-xing-zi-xue-bi-ji/</id>
        <link href="https://panson.top/post/da-mo-xing-zi-xue-bi-ji/">
        </link>
        <updated>2025-12-27T08:30:24.000Z</updated>
        <summary type="html"><![CDATA[<p>这周终于稍微清闲了一些，找许多朋友一起聊了许多东西，关于关于职业、生活、旅行、健康，当然聊着聊着就会聊到大模型，看看其他公司大模型落地的现状。比起快手、美团、拼多多等公司，阿里和字节系确实在落地上更进一步，整体上对 AI 的拥抱程度是更上一个层次的。</p>
]]></summary>
        <content type="html"><![CDATA[<p>这周终于稍微清闲了一些，找许多朋友一起聊了许多东西，关于关于职业、生活、旅行、健康，当然聊着聊着就会聊到大模型，看看其他公司大模型落地的现状。比起快手、美团、拼多多等公司，阿里和字节系确实在落地上更进一步，整体上对 AI 的拥抱程度是更上一个层次的。</p>
<!-- more -->
<figure data-type="image" tabindex="1"><img src="https://images.unsplash.com/photo-1766345907386-3eff10cb9142?q=80&amp;w=2728&amp;auto=format&amp;fit=crop&amp;ixlib=rb-4.1.0&amp;ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D" alt="" loading="lazy"></figure>
<p>让我有点讶异的是腾讯，也有可能是我身边在腾讯的朋友提供的样例不具有代表性，腾讯的大模型能力建设真的很弱，混元大模型的能力与其他同等体量的公司相比，落后了许多，但腾讯的产品又做得蛮好的，我最近用的最多的两款产品，一款是腾讯元宝，一款是 ima.copilot，都是腾讯的产品。</p>
<p>从这一点上来思考的话，产品的受欢迎程度，有时候与基座大模型的评分，不一定是正比的。阿里千问我也用了蛮多时间，虽然大模型评分很高，但在相同的提示词下，我个人体感上是不如 chatGPT 和 Gemini 的，甚至不如 deepseek R1，尤其是上下问长度变大的时候，通义千问的回答幻觉很大，甚至开始出现胡诌的现象，观感很不好，不知道是不是为了节约成本，限制了上下文长度。</p>
<p>未来半年到一年，我的计划是社招顺利 landing 和深度学习大模型应用开发。<br>
一方面，社招顺利 landing，深耕传统后端开发的能力建设，主要深入理解新的业务，提升自己架构设计能力，另一方面则是拥抱变化，深度学习大模型应用开发。</p>
<p>大模型应用开发和传统的后端开发，还是有很多不同的，算是一个新的领域了。<br>
对于新领域的学习，我觉得最难的点在于找到方向，找到正确的方向后，后续就只剩下持续学习了，一切都会水到渠成的。</p>
<p>所以最近一直在找朋友们聊天，结合和朋友们的聊天，我列了一下未来学习计划。</p>
<p>大体上分为以下几个大模块：</p>
<ol>
<li>Agent</li>
<li>RAG</li>
<li>提示词工程</li>
<li>模型基础</li>
<li>SFT/RL</li>
<li>前沿知识</li>
<li>模型推理</li>
<li>项目实战</li>
</ol>
<p>（感觉内容还是有点多的，持续学习，也持续更新中~）</p>
<p>再细分一下：</p>
<h1 id="一-agent-知识架构"><strong>一、Agent 知识架构</strong></h1>
<h4 id="1-python-基础"><strong>1. Python 基础</strong></h4>
<ul>
<li>学习：快速入门 Python 实战教程</li>
</ul>
<h4 id="2-agent-入门-了解-agent"><strong>2. Agent 入门 / 了解 Agent</strong></h4>
<ul>
<li>Agent 特点</li>
<li>LLM 如何调用</li>
<li>实战：快速跑通一个 Agent</li>
</ul>
<h4 id="3-mcp-协议-function-call"><strong>3. MCP 协议 / Function Call</strong></h4>
<ul>
<li>MCP 协议是什么 / 特点 / 两种通信模式</li>
<li>实战：感受 / 体会 MCP</li>
<li>Function Call 的特点</li>
<li>实战：Agent 调用 Function Call</li>
</ul>
<h4 id="4-agent-框架"><strong>4. Agent 框架</strong></h4>
<ul>
<li>
<p>框架了解</p>
<ul>
<li>LangChain</li>
<li>LangGraph</li>
<li>LangSmith</li>
</ul>
</li>
<li>
<p>其他平台/框架</p>
<ul>
<li>扣子</li>
<li>Dify</li>
</ul>
</li>
</ul>
<h4 id="5-agent-评估方法"><strong>5. Agent 评估方法</strong></h4>
<h4 id="6-agent-设计范式"><strong>6. Agent 设计范式</strong></h4>
<h4 id="7-实战复杂的-agent-例子"><strong>7. 实战：复杂的 Agent 例子</strong></h4>
<h1 id="二-rag-知识架构">二、RAG 知识架构</h1>
<h4 id="1-rag入门-体会"><strong>1. RAG入门 / 体会</strong></h4>
<ul>
<li>
<p><strong>RAG是什么？为什么要RAG</strong>：理解基本概念与价值。</p>
</li>
<li>
<p><strong>RAG开发环境</strong>：搭建所需的开发环境。</p>
</li>
<li>
<p><strong>实战：写一个简单的RAG</strong>：通过实践快速上手。</p>
</li>
</ul>
<h4 id="2-向量数据库"><strong>2. 向量数据库</strong></h4>
<ul>
<li>
<p><strong>为什么RAG要使用向量数据库</strong>：了解其必要性。</p>
</li>
<li>
<p><strong>向量数据库的特点/好处</strong>：掌握其核心优势。</p>
</li>
<li>
<p><strong>常见的向量数据库</strong>：认识主流工具与平台。</p>
</li>
</ul>
<h4 id="3-rag的具体过程和策略"><strong>3. RAG的具体过程和策略</strong></h4>
<ul>
<li>
<p><strong>概念</strong></p>
<ul>
<li>理解RAG涉及哪些过程：从宏观上把握核心步骤。</li>
</ul>
</li>
<li>
<p><strong>自然语言转嵌入向量</strong>：将查询和文本转化为向量的过程。</p>
</li>
<li>
<p><strong>分块</strong></p>
<ul>
<li><strong>分块策略</strong>：掌握文本分割的方法与技巧。</li>
</ul>
</li>
<li>
<p><strong>文本召回</strong></p>
<ul>
<li>
<p><strong>文本召回基础</strong>：理解召回的基本原理。</p>
</li>
<li>
<p><strong>稠密向量 / 稀疏向量</strong>：了解两种主要的向量表示方法。</p>
</li>
</ul>
</li>
<li>
<p><strong>效果评估</strong>：评估RAG系统性能的指标与方法。</p>
</li>
<li>
<p><strong>实战：复杂RAG例子</strong>：通过一个综合案例深化理解。</p>
</li>
</ul>
<h1 id="三-提示词工程">三、提示词工程</h1>
<ol>
<li>
<p><strong>设计提示词的原则</strong></p>
<ul>
<li>明确性、具体性、提供上下文、设定角色等。</li>
</ul>
</li>
<li>
<p><strong>常见的提示词策略</strong></p>
<ul>
<li>零样本提示、少样本提示、思维链、指令模板等。</li>
</ul>
</li>
</ol>
<h1 id="四-模型基础">四、 模型基础</h1>
<ol>
<li>
<p><strong>深度学习/机器学习基础</strong></p>
<ul>
<li>神经网络基本原理、训练与优化等。</li>
</ul>
</li>
<li>
<p><strong>Transformer 基础</strong></p>
<ul>
<li>
<p><strong>生成式/自回归模型</strong>：GPT 等模型的原理。</p>
</li>
<li>
<p><strong>词嵌入</strong>：将文本转换为向量的技术。</p>
</li>
<li>
<p><strong>编码器/解码器</strong>：Transformer 的核心架构。</p>
</li>
<li>
<p><strong>注意力机制</strong>：模型理解上下文的关键。</p>
</li>
</ul>
</li>
<li>
<p><strong>不同模型对比</strong></p>
<ul>
<li>
<p><strong>不同模型特点</strong>：对比各类大模型（如 GPT、Claude、LLaMA 等）的优劣势。</p>
</li>
<li>
<p><strong>模型选型</strong>：根据任务需求选择合适模型的考量。</p>
</li>
<li>
<p><strong>不同模型架构</strong>：了解自回归、编码-解码等不同架构。</p>
</li>
</ul>
</li>
<li>
<p><strong>模型训练流程</strong></p>
<ul>
<li>
<p><strong>预训练 / SFT</strong>：模型训练的前两个主要阶段。</p>
</li>
<li>
<p><strong>强化学习 / 推理</strong>：高级优化阶段与模型应用。</p>
</li>
</ul>
</li>
</ol>
<h1 id="五-sft-rl-监督微调与强化学习"><strong>五、 SFT / RL (监督微调与强化学习)</strong></h1>
<ol>
<li>
<p><strong>常见微调策略</strong></p>
<ul>
<li>
<p>全量 / 部分参数微调</p>
</li>
<li>
<p>LoRA</p>
</li>
<li>
<p>Adapter Tuning</p>
</li>
<li>
<p>P-Tuning</p>
</li>
</ul>
</li>
<li>
<p><strong>强化学习</strong></p>
<ul>
<li>
<p><strong>概念</strong>：基本定义与原理。</p>
</li>
<li>
<p><strong>方法</strong>：常用技术（如PPO、DPO等）。</p>
</li>
</ul>
</li>
<li>
<p><strong>实战：DPO / LoRA</strong></p>
<ul>
<li>
<p>怎么选型</p>
</li>
<li>
<p>数据集准备</p>
</li>
<li>
<p>用什么平台 / 怎么做的</p>
</li>
<li>
<p>如何评估和部署</p>
</li>
</ul>
</li>
</ol>
<h1 id="六-前沿知识能力"><strong>六、 前沿知识能力</strong></h1>
<ol>
<li>
<p><strong>最新论文</strong>：跟踪与研究领域前沿学术成果。</p>
</li>
<li>
<p><strong>Claud、 Genimi3 pro……</strong>：了解特定前沿模型。</p>
</li>
</ol>
<h1 id="七-量化-推理"><strong>七、 量化 / 推理</strong></h1>
<ol>
<li>
<p><strong>常见的推理框架</strong>：了解部署和运行模型的工具（如vLLM、TGI等）。</p>
</li>
<li>
<p><strong>模型压缩策略</strong></p>
<ul>
<li>
<p><strong>量化</strong>：降低模型数值精度以减少计算和存储开销。</p>
</li>
<li>
<p>剪枝</p>
</li>
<li>
<p>蒸馏</p>
</li>
</ul>
</li>
<li>
<p><strong>实战</strong></p>
<ul>
<li><strong>量化</strong>：具体的量化实践操作。</li>
</ul>
</li>
</ol>
<h1 id="八-设计项目实战"><strong>八、 设计项目实战</strong></h1>
<ol>
<li>
<p><strong>技术点</strong>：项目所涉及的核心技术。</p>
</li>
<li>
<p><strong>深度</strong>：对技术应用的深入程度。</p>
</li>
<li>
<p><strong>价值</strong>：项目的实际意义与应用价值。</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[十万字长文深度解析 WES 架构设计与重构实践 ]]></title>
        <id>https://panson.top/post/wes-jiagou-sheji-yu-chonggoushijian/</id>
        <link href="https://panson.top/post/wes-jiagou-sheji-yu-chonggoushijian/">
        </link>
        <updated>2025-12-11T10:58:57.000Z</updated>
        <summary type="html"><![CDATA[<p>朋友们好，感谢阅读，本文是一篇超长的文章，数了数，目前零零碎碎写了十余万字，还在慢慢整理中，我将系统性聊聊 WES 架构设计与重构实践，后续如果有精力，会继续增补一些内容。</p>
]]></summary>
        <content type="html"><![CDATA[<p>朋友们好，感谢阅读，本文是一篇超长的文章，数了数，目前零零碎碎写了十余万字，还在慢慢整理中，我将系统性聊聊 WES 架构设计与重构实践，后续如果有精力，会继续增补一些内容。</p>
<!-- more -->
<p>注：</p>
<ul>
<li>本文所有技术图片图床都在GitHub，需要网络代理才能流畅访问。</li>
<li>文章很长，因为是静态博客，所以加载速度会稍微慢一些。</li>
<li>能力和精力有限，文章内容仅代表个人观点。</li>
<li>有些图示画得比较粗糙~，我觉得清晰化的内容表达比图示的精美要更重要，实在是精力有限，简单图我都是让 chatGPT 帮我生成的。</li>
<li>感谢阅读，业务存在边界，但技术没有终点，拥抱变化！</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://images.unsplash.com/photo-1764014588206-3c2647a34911?q=80&amp;w=2711&amp;auto=format&amp;fit=crop&amp;ixlib=rb-4.1.0&amp;ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D" alt="" loading="lazy"></figure>
<p>目前计划写的内容主要涉及到一下几点：</p>
<ul>
<li>WES 在供应链、履约链路的系统定位</li>
<li>核心功能</li>
<li>应用架构</li>
<li>核心链路</li>
<li>三级库存模型</li>
<li>出库效率优化：热度移位、flowpick、超 A 不返库……</li>
<li>调度模型</li>
<li>数据一致性保障</li>
<li>策略规则治理</li>
<li>流程引擎</li>
<li>.……</li>
</ul>
<p>总览图：<br>
<img src="https://github.com/PansonPanson/supply-chain/blob/main/%E4%BE%9B%E5%BA%94%E9%93%BE%E5%AD%90%E7%B3%BB%E7%BB%9F/%E6%99%BA%E8%83%BD%E4%BB%93%E5%82%A8%E7%B3%BB%E7%BB%9F/%E9%87%8D%E6%9E%84%E7%AF%87/assets/%E5%8D%81%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%20WES%20%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E9%87%8D%E6%9E%84%E5%AE%9E%E8%B7%B5/file-20251214124240805.png?raw=true" alt="" loading="lazy"></p>
<h1 id="一-wes-在供应链-履约链路的系统定位">一、WES 在供应链、履约链路的系统定位</h1>
<p>在<strong>仓储领域的 WES（Warehouse Execution System，仓储执行系统）<strong>中，</strong>“上游系统”并不是唯一的一个，而是一组业务系统</strong>。从<strong>业务流 / 数据流角度</strong>来看，WES 主要承接“计划与业务决策”，向下驱动“设备与执行”。</p>
<h2 id="11-最典型的上游系统">1.1、最典型的上游系统</h2>
<h3 id="wmswarehouse-management-system最核心上游">WMS（Warehouse Management System）——最核心上游</h3>
<p><strong>WMS → WES 传什么？</strong></p>
<ul>
<li>出库单 / 入库单/盘点单……</li>
<li>商品、库存调整单……</li>
<li>作业策略（拣选规则、优先级）</li>
</ul>
<p><strong>WES 的角色</strong></p>
<ul>
<li>将 WMS 的“业务任务”拆解为可执行任务</li>
<li>调度、控速、并发控制</li>
<li>动态调整执行顺序</li>
</ul>
<h3 id="omsorder-management-system">OMS（Order Management System）</h3>
<p>在<strong>电商 / 履约中心</strong>中非常常见。</p>
<p><strong>OMS → WMS / WES</strong></p>
<ul>
<li>客户订单</li>
<li>交付 SLA</li>
<li>订单优先级（如加急 / 普通）</li>
</ul>
<p>有两种架构：</p>
<pre><code>OMS → WMS → WES
OMS → WES（直连，较少但存在）
</code></pre>
<h3 id="erp企业资源计划系统">ERP（企业资源计划系统）</h3>
<p>更多是 <strong>宏观计划级别</strong>：</p>
<ul>
<li>
<p>采购计划</p>
</li>
<li>
<p>发运计划</p>
</li>
<li>
<p>财务 / 主数据</p>
</li>
</ul>
<p>通常 <strong>不直接驱动 WES</strong>，而是：</p>
<pre><code>ERP → OMS / WMS → WES
</code></pre>
<h3 id="tms运输管理系统">TMS（运输管理系统）</h3>
<p>在出库履约场景：</p>
<ul>
<li>
<p>发车时间</p>
</li>
<li>
<p>运输批次</p>
</li>
<li>
<p>装车顺序</p>
</li>
</ul>
<p>影响 WES 的：</p>
<ul>
<li>
<p>出库任务优先级</p>
</li>
<li>
<p>波次切分规则</p>
</li>
</ul>
<hr>
<h2 id="12-从职责边界看上下游">1.2、从“职责边界”看上下游</h2>
<h3 id="业务分层视角">业务分层视角</h3>
<pre><code>【业务决策层】
ERP / OMS / TMS
        ↓
【仓储管理层】
        WMS
        ↓
【执行编排层】
        WES   
        ↓
【车辆调度集群层】
        WCS（WCS、RCS集群）
        ↓
【物理设备层】
    输送线 / AGV / 堆垛机 / 机械臂
</code></pre>
<h2 id="13-以电商履约链路为例">1.3、以电商履约链路为例</h2>
<p>以电商履约链路为例，WES 在 WMS 的下游，不分场景下，OMS 和 ERP 也会直接对接 WES。<br>
WES 的业务链路位置大致参考下图（做了一些简化）：<br>
<img src="https://github.com/PansonPanson/supply-chain/blob/main/%E4%BE%9B%E5%BA%94%E9%93%BE%E5%AD%90%E7%B3%BB%E7%BB%9F/%E6%99%BA%E8%83%BD%E4%BB%93%E5%82%A8%E7%B3%BB%E7%BB%9F/%E9%87%8D%E6%9E%84%E7%AF%87/image/4/file-20251121004900019.png?raw=true" alt="" loading="lazy"></p>
<h1 id="二-wes-核心功能">二、WES 核心功能</h1>
<p>狭义的 WES 系统更侧重调度执行层，它不是“管业务”，也不是“控设备”，而是“把业务计划高效、稳定、实时地执行下去”， 从这个层面上来说，WES 的核心功能是：任务编排、执行调度、节拍控制、状态协同与异常恢复：</p>
<ol>
<li>将 WMS 的业务任务拆解并编排为可执行任务；</li>
<li>对任务进行调度、并发与节拍控制；</li>
<li>统一管理任务与设备状态；</li>
<li>在异常情况下保证任务可恢复执行；</li>
<li>作为业务系统与设备系统之间的执行中枢。</li>
</ol>
<p>但实际在实际的系统中，WES 还会兼管 WMS 的许多功能，比如单据管理、仓内基础数据管理、库存管理等等。</p>
<h2 id="21-wes-调度能力的核心功能">2.1、WES 调度能力的核心功能</h2>
<h3 id="1-任务拆解与编排task-orchestration">1 任务拆解与编排（Task Orchestration）</h3>
<p><strong>从“业务任务”到“可执行任务”</strong></p>
<p><strong>来源</strong></p>
<ul>
<li>WMS 下发：入库单、出库单、波次、移库任务</li>
</ul>
<p><strong>WES 要做什么</strong></p>
<ul>
<li>
<p>拆单（一个出库单 → 多个拣选 / 搬运 / 输送任务）</p>
</li>
<li>
<p>建 DAG / 状态机（先拣 → 再合流 → 再出库）</p>
</li>
<li>
<p>任务依赖、前后置约束</p>
</li>
</ul>
<h3 id="2-执行调度与并发控制scheduling">2 执行调度与并发控制（Scheduling）</h3>
<p><strong>这是 WES 的“灵魂”</strong></p>
<p>WES 不只是“发任务”，而是<strong>控制“怎么发、发多少、先发谁”</strong>。</p>
<p><strong>典型能力</strong></p>
<ul>
<li>
<p>多队列调度（按库区 / 设备 / 业务类型）</p>
</li>
<li>
<p>优先级调度（加急单 / SLA）</p>
</li>
<li>
<p>并发度控制（每秒 N 个任务）</p>
</li>
<li>
<p>公平 / 抢占 / 权重调度</p>
</li>
</ul>
<h3 id="3-节拍控制-控速下发throttling">3 节拍控制 / 控速下发（Throttling）</h3>
<p><strong>防止设备被“打爆”</strong></p>
<p>为什么要 WES？</p>
<ul>
<li>下游车辆调度系统和搬运系统存在能力限制</li>
</ul>
<p><strong>WES 能力</strong></p>
<ul>
<li>
<p>QPS 控制（如：每秒最多 20 个任务）</p>
</li>
<li>
<p>滑动窗口 / 漏桶 / 令牌桶</p>
</li>
<li>
<p>按设备维度限流</p>
</li>
<li>
<p>动态调整速率（高峰 / 低谷）</p>
</li>
</ul>
<p>从这个角度讲， WES ≈ <strong>业务侧的“调度 + 限流中枢”</strong></p>
<h3 id="4-状态管理与协同state-management">4 状态管理与协同（State Management）</h3>
<p><strong>全链路状态可视</strong></p>
<p><strong>WES 维护</strong></p>
<ul>
<li>单据状态机</li>
<li>作业单状态机</li>
<li>任务状态（初始状态、 待分库存、 待下发、 待推实操、 待实操、 完成、 回滚）</li>
</ul>
<p><strong>价值</strong></p>
<ul>
<li>
<p>避免“任务丢失”</p>
</li>
<li>
<p>支持失败重试、补偿</p>
</li>
<li>
<p>支持暂停 / 恢复</p>
</li>
</ul>
<p>📌 常见实现</p>
<ul>
<li>
<p>状态机</p>
</li>
<li>
<p>事件驱动（状态变更触发下一步）</p>
</li>
</ul>
<h3 id="5-异常处理与恢复">5 异常处理与恢复</h3>
<p><strong>真实生产环境最重要的一点</strong></p>
<p>异常包括：</p>
<ul>
<li>
<p>设备故障</p>
</li>
<li>
<p>通道堵塞</p>
</li>
<li>
<p>WCS 超时 / 无响应</p>
</li>
<li>
<p>任务执行失败</p>
</li>
</ul>
<p><strong>WES 的职责</strong></p>
<ul>
<li>
<p>超时检测</p>
</li>
<li>
<p>重试 / 改道 / 降级</p>
</li>
<li>
<p>人工介入（挂起、人工确认）</p>
</li>
<li>
<p>任务回滚或补偿</p>
</li>
</ul>
<h2 id="22-wes-调度能力的非核心但关键能力">2.2、WES 调度能力的“非核心但关键”能力</h2>
<h3 id="1-执行监控-可视化">1 执行监控 &amp; 可视化</h3>
<ul>
<li>
<p>实时任务看板</p>
</li>
<li>
<p>吞吐量 / 延迟</p>
</li>
<li>
<p>堵点识别</p>
</li>
</ul>
<h3 id="2-策略规则动态配置能力">2 策略规则动态配置能力</h3>
<ul>
<li>
<p>调度策略可配置</p>
</li>
<li>
<p>限流参数动态调整</p>
</li>
<li>
<p>不同业务场景复用</p>
</li>
</ul>
<h3 id="3-与-wcs-的协议适配">3 与 WCS 的协议适配</h3>
<ul>
<li>
<p>REST / MQ / TCP</p>
</li>
<li>
<p>幂等、ACK、重试</p>
</li>
</ul>
<h2 id="23-wes-业务功能">2.3 WES 业务功能</h2>
<p>这部分功能是兼管了 WMS 的功能。</p>
<h3 id="231-基础数据管理系统的基石">2.3.1、 基础数据管理：系统的基石</h3>
<p>任何智能系统的运行都依赖于准确、完整的基础数据。：</p>
<ul>
<li><strong>货主与商品管理</strong>：支持货主信息的新增、编辑、删除、查询、导入/导出及有效性管理。商品（SKU）管理同样全面，支持一个产品对应多个编码，并可维护商品图片、规格、供应商、ABC分类等丰富信息。</li>
<li><strong>容量与条码管理</strong>：维护商品在不同容器（货架库位、料箱料格）中的容量数据，系统可根据上架记录自动更新。同时管理商品条码的匹配关系，确保扫描识别的准确性。</li>
<li><strong>容器与库位管理</strong>：对货架、料箱、料格、库位等物理存储单元进行全生命周期管理，包括类型定义、有效性控制和可视化布局编排。</li>
</ul>
<h3 id="232-入库管理高效收货上架">2.3.2、 入库管理：高效收货上架</h3>
<p>WES支持多种灵活的上架模式，适应不同业务场景：</p>
<ul>
<li><strong>多种上架模式</strong>：
<ul>
<li><strong>直接上架</strong>：适用于已知明确上架库位的场景，支持整托、整箱上架。</li>
<li><strong>理货上架</strong>：针对零散商品，系统推荐合并库位，先下架整理再上架，以优化存储空间。</li>
<li><strong>在线/离线工作站操作</strong>：提供图形化的工作站界面（在线）和PDA操作（离线），引导操作员完成扫描容器、商品、库位、确认数量等步骤。</li>
</ul>
</li>
<li><strong>入库单管理</strong>：支持手动创建、导入或接口下发入库单，并对入库单进行提交、取消、关闭等全流程状态管理。</li>
<li><strong>策略与容错</strong>：支持混放规则控制（控制不同商品或批次能否共存）、商品容量计算，并提供了“无合适库位”时的处理机制，如将商品转移至暂存区并自动生成返库上架单。</li>
</ul>
<h3 id="233-出库管理智能拣选与分播">2.3.3、 出库管理：智能拣选与分播</h3>
<p>出库是WES的核心价值体现，其功能设计旨在最大化拣选效率和准确率：</p>
<ul>
<li><strong>出库单与波次管理</strong>：支持出库单、集合单的创建、提交、指定工作站、优先级调整、取消及缺货发货。系统支持<strong>静态组波</strong>（T+1场景，预先组单）和<strong>动态组波</strong>（即时订单，实时优化），提升订单聚合效率。</li>
<li><strong>智能化拣选作业</strong>：
<ul>
<li><strong>任务调度</strong>：根据策略自动将出库任务分配至最优工作站，并调度对应的货架或料箱到站。</li>
<li><strong>多样化拣选模式</strong>：支持按单拣选、按箱拣选。系统提供清晰的实操界面，引导操作员从指定库位拣选商品放入指定分播墙槽位，支持扫描校验、缺拣记录、后置绑箱等操作。</li>
<li><strong>可视化辅助</strong>：工作站界面显示库位/槽位状态（绿色有单、红色缺货等）、商品图片、拣选数量，并可与电子标签灯（PTL）联动，实现“灯光拣选”。</li>
</ul>
</li>
<li><strong>策略中心深度配置</strong>：出库环节拥有丰富的可配置策略，如拣选库存分配算法（效率优先/清库存优先）、缺货提交方式、扫码校验严格度（不需要/需要/逐件扫描）、槽位容量比例、临近超时与槽位超时释放策略等，实现高度定制化。</li>
</ul>
<h3 id="234-库内管理精益化库存运营">2.3.4、 库内管理：精益化库存运营</h3>
<p>为保障库存准确性及优化库内结构，WES提供了强大的库内管理工具：</p>
<ul>
<li><strong>在线盘点</strong>：支持明盘与盲盘，可按商品、按容器、动碰（按日期或单据）、全盘等多种方式创建盘点单。操作员在工作站直接清点，系统自动比对差异并记录原因（盘盈/盘亏），可自动生成库存调整单或复盘单。</li>
<li><strong>在线理货</strong>：用于整合零散库存。操作员可申请理货任务，系统将需要合并的商品从分散的库位下架至工作站槽位，再引导其上架至合并后的目标库位，过程中自动处理多货、少货等异常。</li>
<li><strong>库存调整</strong>：支持通过库存调整单、批次属性调整单、货权调整单，对系统库存数量、批次属性、货主归属进行手工修正，处理盘点差异、理货差异等异常。</li>
</ul>
<h3 id="235-库存可视化与查询">2.3.5、 库存可视化与查询</h3>
<p>WES提供多层次的库存视图，助力精细化管理：</p>
<ul>
<li><strong>二级库存</strong>：按“仓库+库区+货主+商品+批次属性”维度聚合显示库存总量。</li>
<li><strong>三级库存</strong>：细化到“容器+库位”级别，可查看每个具体储位上的库存详情、锁定数量及被出库单占用的数量。</li>
<li><strong>实时库存占用查询</strong>：实时追踪出库单对二、三级库存的占用情况。</li>
<li><strong>库存日志</strong>：记录所有库存变化流水，便于追溯和审计。</li>
</ul>
<h3 id="236-策略与配置中心系统的控制台">2.3.6、 策略与配置中心：系统的控制台</h3>
<p>WES的强大之处在于其高度的可配置性，用户可以通过策略中心和配置中心精细控制系统行为：</p>
<ul>
<li><strong>策略中心</strong>：以规则引擎的形式，管理出库、入库、盘点、打印等各环节的策略。例如，设置出库单初始优先级、是否自动提交、缺货处理方式、混放控制规则、装箱清单打印策略等。支持为不同条件（如货主、单据类型）设置不同的规则和优先级。</li>
<li><strong>配置中心</strong>：提供大量开关和参数配置，如是否启用逐件扫描、是否允许取消作业中的出库单、提前离站设置、盘点任务上限、接口反馈内容等，满足不同仓库的个性化流程需求。</li>
</ul>
<h3 id="237-系统管理与集成">2.3.7、 系统管理与集成</h3>
<ul>
<li><strong>用户与权限管理</strong>：支持多用户账号、角色权限控制，保障系统安全。</li>
<li><strong>多语言与外观</strong>：支持中、英、日等多语言包，并可自定义系统LOGO和主题。</li>
<li><strong>丰富的API接口</strong>：提供了与上游业务系统（如ERP、WMS）集成的完整接口集，涵盖商品同步、入库单/出库单/盘点单的下发与反馈、库存查询、调整单同步等，实现业务流程无缝对接。</li>
<li><strong>工作站管理</strong>：支持在线工作站、PDA等多种终端设备的配置与管理。</li>
</ul>
<h1 id="三-wes-应用架构">三、WES 应用架构</h1>
<ol>
<li>
<p><strong>展现层</strong>：面向各类用户的<strong>交互窗口</strong>，包括管理员使用的WEB后台、自动化设备接口（DEVICE）和现场操作员手持的PDA。</p>
</li>
<li>
<p><strong>应用层</strong>：WES系统的<strong>大脑与核心</strong>，所有业务逻辑、调度规则。</p>
</li>
<li>
<p><strong>数据层</strong>：系统的<strong>记忆中枢</strong>，使用MySQL存储核心业务数据，Redis支撑高并发缓存，MongoDB可能处理日志等非结构化数据，Drools则独立管理策略规则。</p>
</li>
<li>
<p><strong>基础设施层</strong>：系统的<strong>躯体与感官</strong>，基于Docker实现容器化部署，并通过一系列监控工具（如Prometheus、Grafana）保障系统健康运行。</p>
</li>
</ol>
<p><strong>中间件</strong>（如RocketMQ、XXL-JOB、动态线程池）贯穿各层，负责异步通信、定时任务调度等，保障系统高可用与可扩展。</p>
<figure data-type="image" tabindex="2"><img src="https://github.com/PansonPanson/supply-chain/blob/main/%E4%BE%9B%E5%BA%94%E9%93%BE%E5%AD%90%E7%B3%BB%E7%BB%9F/%E6%99%BA%E8%83%BD%E4%BB%93%E5%82%A8%E7%B3%BB%E7%BB%9F/%E9%87%8D%E6%9E%84%E7%AF%87/assets/%E5%8D%81%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%20WES%20%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E9%87%8D%E6%9E%84%E5%AE%9E%E8%B7%B5/file-20251213164857314.png?raw=true" alt="" loading="lazy"></figure>
<h1 id="四-wes-核心链路">四、WES 核心链路</h1>
<h2 id="41-出库正向链路">4.1、出库正向链路</h2>
<p>我们先聊聊出库核心链路。</p>
<h3 id="阶段一订单创建与初始状态-待分配">阶段一：订单创建与初始状态 (<code>待分配</code>)</h3>
<ul>
<li>
<p><strong>起点</strong>：上游系统（如OMS）下发出库单，WES创建订单，初始状态为 <strong><code>待分配</code></strong>。</p>
</li>
<li>
<p><strong>核心操作</strong>：<strong>库存预占</strong>。此时并不实际扣减库存，而是预先锁定库存量，防止超卖，保证了库存数据的一致性。</p>
</li>
</ul>
<h3 id="阶段二库存分配与策略决策-待分配-待下发">阶段二：库存分配与策略决策 (<code>待分配</code>-&gt; <code>待下发</code>)</h3>
<p>这是<strong>WES智能化集中体现的关键环节</strong>。</p>
<ul>
<li>
<p><strong>核心操作：库存分配</strong>。系统需要决策“从哪个或多个货位，拣选哪个批次的商品来满足此订单”。</p>
</li>
<li>
<p><strong>策略规则引擎介入</strong>：分配过程会调用<strong>规则引擎（如Drools）</strong>，基于预设策略进行计算，例如：</p>
<ul>
<li>
<p><strong>货位优先级</strong>：就近原则、先入先出原则。</p>
</li>
<li>
<p><strong>效率最优</strong>：减少拣货员行走路径、最大化单车载货量。</p>
</li>
<li>
<p><strong>库存优化</strong>：优先消耗临期库存。</p>
</li>
</ul>
</li>
<li>
<p><strong>结果</strong>：分配成功后，订单状态跃迁至 <strong><code>待下发</code></strong>。</p>
</li>
</ul>
<h3 id="阶段三任务组单与指令下发-待下发-执行中">阶段三：任务组单与指令下发 (<code>待下发</code>-&gt; <code>执行中</code>)</h3>
<p>此阶段的核心是 <strong>“任务组单”</strong>，目的是<strong>提升现场作业效率</strong>。</p>
<ul>
<li>
<p><strong>核心操作</strong>：系统不会立即处理一个订单，而是将一段时间内多个订单的拣货任务进行<strong>聚合与优化</strong>。</p>
<ul>
<li>
<p>将去往同一区域或相邻货位的任务合并，生成一张高效的<strong>拣货波次</strong>。</p>
</li>
<li>
<p>这就是图中 **“任务树”**​ 概念的应用，将多个订单任务聚合为一棵更优的任务树。</p>
</li>
</ul>
</li>
<li>
<p><strong>指令下发</strong>：组单完成后，WES通过<strong>WCS/RCS接口</strong>将具体的拣货指令下发给自动化设备（如亮灯拣选、AGV调度），订单状态变为 <strong><code>执行中</code></strong>。</p>
</li>
</ul>
<h3 id="阶段四任务树驱动与现场执行-执行中">阶段四：任务树驱动与现场执行 (<code>执行中</code>)</h3>
<p>订单进入<strong>物理执行阶段</strong>，由 **“任务树”**​ 驱动，将一个订单分解为一系列有序的原子任务。</p>
<ul>
<li>
<p><strong>任务分解</strong>：</p>
<ol>
<li>
<p><strong>生成拣货任务</strong>：拣货员或设备根据指令到指定货位拣选指定数量的商品。</p>
</li>
<li>
<p><strong>生成搬运任务</strong>：AGV等设备将拣选出的商品搬运至复核台。</p>
</li>
<li>
<p><strong>生成工作站复核任务</strong>：系统提示复核员扫描商品，确保拣选的准确性。</p>
</li>
<li>
<p><strong>生成打包任务</strong>：复核无误后，系统生成打包任务，并打印面单。</p>
</li>
</ol>
</li>
<li>
<p><strong>状态管理</strong>：每个子任务都有其自身的状态（如<code>待执行</code>、<code>执行中</code>、<code>已完成</code>），WES需要实时追踪整个任务树的完成进度。</p>
</li>
</ul>
<h3 id="阶段五最终确认与完成-执行中-已完成">阶段五：最终确认与完成 (<code>执行中</code>-&gt; <code>已完成</code>)</h3>
<ul>
<li>
<p><strong>核心操作</strong>：当订单的所有子任务（拣、搬、复、包）都完成后，系统进行<strong>最终确认</strong>。</p>
</li>
<li>
<p><strong>库存扣减</strong>：此时才在数据库中进行<strong>实际的库存扣减</strong>，确保账实相符。</p>
</li>
<li>
<p><strong>状态跃迁</strong>：订单状态最终变为 <strong><code>已完成</code></strong>，并向OMS等上游系统回传完成信息。</p>
</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://github.com/PansonPanson/supply-chain/blob/main/%E4%BE%9B%E5%BA%94%E9%93%BE%E5%AD%90%E7%B3%BB%E7%BB%9F/%E6%99%BA%E8%83%BD%E4%BB%93%E5%82%A8%E7%B3%BB%E7%BB%9F/%E9%87%8D%E6%9E%84%E7%AF%87/image/4/file-20251122000925045.png?raw=true" alt="" loading="lazy"></figure>
<h2 id="42-入库正向链路">4.2 入库正向链路</h2>
<p>整个入库流程可以被清晰地划分为三个阶段，体现了从信息录入到物理上架的完整闭环：</p>
<ol>
<li>
<p><strong>【信息预置与准备阶段】</strong>：单据创建与模式选择。</p>
</li>
<li>
<p><strong>【物理收货与绑定阶段】</strong>：货品实收、质检、并与系统容器绑定。</p>
</li>
<li>
<p><strong>【智能上架与执行阶段】</strong>：系统调度资源，完成货品上架，按单、按箱将上架信息反馈给上游系统</p>
</li>
</ol>
<h3 id="阶段一信息预置与准备">阶段一：信息预置与准备</h3>
<p>此阶段是流程的起点，核心是 **“单在先，货在后”**​ ，在系统中搭建好作业框架。</p>
<ul>
<li>
<p><strong>起点</strong>：<strong>上游服务</strong>（如ERP或采购系统）创建并向WES <strong>下发入库单</strong>，单据中包含了预期的货品、数量等信息。</p>
</li>
<li>
<p><strong>WES响应</strong>：WES <strong>保存入库单</strong>，建立本次入库作业的任务主干。</p>
</li>
<li>
<p><strong>现场就绪</strong>：操作员在<strong>STATION工作站</strong>上<strong>上线</strong>，并<strong>开启直接上架业务模式</strong>。此模式意味着收货后可直接规划上架，无需暂存再处理，是提升效率的关键设置。</p>
</li>
</ul>
<h3 id="阶段二物理收货与绑定">阶段二：物理收货与绑定</h3>
<p>此阶段是<strong>实物与信息首次交汇的关键环节</strong>，核心是 <strong>“验明正身，建立关联”</strong>。</p>
<ol>
<li>
<p><strong>PDA扫描收货</strong>：操作员使用<strong>PDA</strong>（手持终端）<strong>选单</strong>，找到对应的入库单。</p>
</li>
<li>
<p><strong>质检与确认</strong>：<strong>选合格</strong>（完成质检操作），然后<strong>选商品、选批次、确认上架数量</strong>。这个过程确保了入库货品的准确性。</p>
</li>
<li>
<p><strong>关键的系统逻辑</strong>：</p>
<ul>
<li>
<p><strong>按规则校验</strong>：此处会调用<strong>策略规则引擎</strong>，校验批次、效期、包装规格等是否符合预设规则。</p>
</li>
<li>
<p><strong>建立绑定关系</strong>：系统执行 <strong>“入库单与容器的绑定(1:n)”<strong>​ 。这是核心概念，意味着</strong>一张入库单的货品，可以放入一个或多个物理容器</strong>（如托盘、料箱）。绑定后，<strong>库存进入“收货暂存区”</strong>，这是一个逻辑库存状态，表示货品已接收但未确定最终货位。</p>
</li>
</ul>
</li>
</ol>
<h3 id="阶段三智能上架与执行">阶段三：智能上架与执行</h3>
<p>此阶段是<strong>WES作为“调度大脑”能力的集中展现</strong>，核心是 <strong>“智能决策，驱动执行”</strong>。</p>
<ol>
<li>
<p><strong>任务生成</strong>：工作站<strong>生成上架申请单</strong>，WES随后<strong>生成上架任务</strong>。这里的“任务”包含了“将哪个容器，放到哪个货位”的完整指令。</p>
</li>
<li>
<p><strong>智能调度与下发</strong>：</p>
<ul>
<li>
<p>WES将任务<strong>下发</strong>给<strong>WCS</strong>（仓库控制系统）。</p>
</li>
<li>
<p>WCS通过<strong>调度算法服务</strong>，计算最优路径，调度**AGV（小车）**​ 前往工作站接取容器。</p>
</li>
</ul>
</li>
<li>
<p><strong>任务执行与监控</strong>：</p>
<ul>
<li>
<p>小车搬运容器前往目标货位，并<strong>异步上报位置</strong>，实现全程可视化监控。</p>
</li>
<li>
<p>WCS<strong>推送实操指令到工作站</strong>，指引操作员（或自动化设备）完成最终放置动作。</p>
</li>
<li>
<p>操作员确认后，<strong>上架完成</strong>，反馈信息。</p>
</li>
</ul>
</li>
<li>
<p><strong>最终确认与反馈</strong>：</p>
<ul>
<li>
<p>小车<strong>离站</strong>，资源释放。</p>
</li>
<li>
<p>系统通过<strong>反馈定时器</strong>，按单或按箱<strong>批量、异步</strong>地<strong>反馈结果给上游服务</strong>，并<strong>更新单据状态为完成</strong>。这种异步反馈机制避免了阻塞主流程，提升了系统整体性能。</p>
</li>
</ul>
</li>
</ol>
<figure data-type="image" tabindex="4"><img src="https://github.com/PansonPanson/supply-chain/blob/main/%E4%BE%9B%E5%BA%94%E9%93%BE%E5%AD%90%E7%B3%BB%E7%BB%9F/%E6%99%BA%E8%83%BD%E4%BB%93%E5%82%A8%E7%B3%BB%E7%BB%9F/%E9%87%8D%E6%9E%84%E7%AF%87/assets/%E5%8D%81%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%20WES%20%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E9%87%8D%E6%9E%84%E5%AE%9E%E8%B7%B5/%E6%96%99%E7%AE%B1%E5%88%B0%E4%BA%BA%E7%BB%84%E7%AE%B1-%E4%B8%8A%E6%9E%B6%E8%B0%83%E5%BA%A6%E6%B5%81%E7%A8%8B.png?raw=true" alt="" loading="lazy"></figure>
<h2 id="43盘点正向链路">4.3盘点正向链路</h2>
<h2 id="44-理货正向链路">4.4 理货正向链路</h2>
<h2 id="45-逆向链路">4.5 逆向链路</h2>
<h1 id="五-三级库存模型">五、三级库存模型</h1>
<h2 id="51-wes-的多级库存模型是怎样的">5.1、WES 的多级库存模型是怎样的？</h2>
<p>WES 的库存模型分为三层：</p>
<ul>
<li>一级库存</li>
<li>二级库存</li>
<li>三级库存<br>
粒度逐件变细。一级库存是全仓库存，商品维度，二级库存是库区+商品+批次+包装，三级库存则细粒度到库位（料箱、料格），与具体的存储位直接关联。<br>
<img src="https://github.com/PansonPanson/supply-chain/blob/main/%E4%BE%9B%E5%BA%94%E9%93%BE%E5%AD%90%E7%B3%BB%E7%BB%9F/%E6%99%BA%E8%83%BD%E4%BB%93%E5%82%A8%E7%B3%BB%E7%BB%9F/%E9%87%8D%E6%9E%84%E7%AF%87/assets/WES%20%E9%87%8D%E6%9E%84%E7%B3%BB%E5%88%97%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9AWES%20%E4%B8%89%E7%BA%A7%E5%BA%93%E5%AD%98%E6%A8%A1%E5%9E%8B/file-20251204214502449.png?raw=true" alt="" loading="lazy"></li>
</ul>
<h2 id="52-一级库存的优势与弊端">5.2、一级库存的优势与弊端？</h2>
<p>先说优势，对于全仓库存的可视化，其实是简单了许多，其次上游调取库存快照时，减少了计算。</p>
<p>劣势也很明显：</p>
<ol>
<li>一级库存是粒度较大，如果是大库存商品并且是热点商品的话，即使是在 B 端也很容易变成热点行，高并发下，出现性能问题。</li>
<li>库存的级数越多，要保证数据一致性的难度就越高，代价也越高。</li>
<li>死锁的风险也会增大<br>
<img src="https://github.com/PansonPanson/supply-chain/blob/main/%E4%BE%9B%E5%BA%94%E9%93%BE%E5%AD%90%E7%B3%BB%E7%BB%9F/%E6%99%BA%E8%83%BD%E4%BB%93%E5%82%A8%E7%B3%BB%E7%BB%9F/%E9%87%8D%E6%9E%84%E7%AF%87/assets/WES%20%E9%87%8D%E6%9E%84%E7%B3%BB%E5%88%97%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9AWES%20%E4%B8%89%E7%BA%A7%E5%BA%93%E5%AD%98%E6%A8%A1%E5%9E%8B/file-20251204214520258.png?raw=true" alt="" loading="lazy"></li>
</ol>
<h2 id="53-重构中如何做取舍">5.3、重构中如何做取舍？</h2>
<p>工作越久，越觉得软件开发中，没有银弹，方案本身没有好坏，只有适合与不适合，大多数时候我们都在做权衡（Trade-Off）。</p>
<p>对于 WES 来说，数据一致性和稳定性比报表类的需求其实是更核心的，一级库存固然有一定优点，但都可以通过二级库存聚合计算得到，而且一级库存的使用场景都很低频，去掉一级库存完全是能满足业务需求的。</p>
<p>去掉一级库存的优势就很明显了，数据一致性的维护更简单了，死锁风险降低，代码层面也会降低复杂度，热点行的发生频率也会下降一个级数。</p>
<p>所以最终还是去掉了一级库存。</p>
<h2 id="54-为什么要有二级库存">5.4、为什么要有二级库存？</h2>
<p>二级库存关注的维度是<strong>单库区商品批次维度</strong>，那我们先假设去掉二级库存，那会有哪些问题？</p>
<ol>
<li><strong>性能：</strong> 在一些需要库区视角的场景中，比如出库单缺货时无法快速判断，影响补货时效，因为三级库存是分散在具体库位的，需要去三级库存表查找目标库存列表，并做聚合计算，尤其在某些仓储场景下，sku 种类很少，那要查询的三级库存数量会很大，对三级库存表是一个很大的负担。</li>
<li><strong>逻辑耦合</strong>：库存决策（是否满足订单）与执行细节（从哪个货位取货）混杂，增加代码复杂度</li>
<li>另外二级库存与我们的出库调度模型有关联，减少二级库存会让上游的出库单与调度任务直接关联，会缺少灵活性。</li>
</ol>
<p>基于上述原因，我们最终还是保留了二级库存。<br>
<img src="https://github.com/PansonPanson/supply-chain/blob/main/%E4%BE%9B%E5%BA%94%E9%93%BE%E5%AD%90%E7%B3%BB%E7%BB%9F/%E6%99%BA%E8%83%BD%E4%BB%93%E5%82%A8%E7%B3%BB%E7%BB%9F/%E9%87%8D%E6%9E%84%E7%AF%87/assets/WES%20%E9%87%8D%E6%9E%84%E7%B3%BB%E5%88%97%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9AWES%20%E4%B8%89%E7%BA%A7%E5%BA%93%E5%AD%98%E6%A8%A1%E5%9E%8B/file-20251204214550611.png?raw=true" alt="" loading="lazy"></p>
<h2 id="55-库存扣减的幂等性如何保证">5.5、库存扣减的幂等性如何保证？</h2>
<p>我们有库存流水表，会有幂等键，二级库存是 出库作业类型 + 作业单 ID + 明细 ID，三级库存扣减是出库作业类型 + 任务 ID。</p>
<h2 id="56-mysql-库存扣减的性能瓶颈与优化思路">5.6、MySQL 库存扣减的性能瓶颈与优化思路？</h2>
<h3 id="1-性能瓶颈">1 性能瓶颈</h3>
<p><img src="https://github.com/PansonPanson/supply-chain/blob/main/%E4%BE%9B%E5%BA%94%E9%93%BE%E5%AD%90%E7%B3%BB%E7%BB%9F/%E6%99%BA%E8%83%BD%E4%BB%93%E5%82%A8%E7%B3%BB%E7%BB%9F/%E9%87%8D%E6%9E%84%E7%AF%87/assets/WES%20%E9%87%8D%E6%9E%84%E7%B3%BB%E5%88%97%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9AWES%20%E4%B8%89%E7%BA%A7%E5%BA%93%E5%AD%98%E6%A8%A1%E5%9E%8B/file-20251204214614333.png?raw=true" alt="" loading="lazy"><br>
MySQL 库存扣减其实本质上是热点行更新的问题，当多个并发事务同时尝试更新同一行热点数据时，可能会导致锁竞争和冲突。这会增加事务的等待时间和冲突概率，导致性能下降，并可能引发死锁问题。<br>
具体来说，可能会产生以下问题（<strong>参考了网络上的内容，学习一下</strong>）：</p>
<ol>
<li>锁竞争，热点数据的更新是通过update语句进行的，而update是需要给记录增加排他锁的，这就会导致大量的请求被阻塞。降低整个系统的吞吐量。</li>
<li>占用数据库连接，当有大量的update语句，因为要修改同一条记录而被阻塞的时候，他们持有的数据库连接是不会释放的，而数据库连接又是有限的，所以会导致连接数不够，进而影响整个系统的吞吐量及可用性。</li>
<li>耗尽数据库CPU，大量锁等待，就会导致大量的自旋，多个线程就会不断的尝试获取锁，CPU就需要不断的执行自旋操作，并且需要做死锁检测，消耗大量CPU时间。并且在这个过程中，操作系统也需要频繁的进行线程上下文的切换，这个过程会导致CPU时间片的浪费。</li>
<li>死锁风险，在高并发的情况下。由于数据库需要频繁定位和更新这些特定行，可能会增加锁竞争和死锁的风险，影响并发性能。</li>
<li>索引维护开销大，频繁地更新热点数据，不仅会导致数据的变化，还可能导致相关索引的频繁维护，这可能会增加数据库的开销，导致性能下降。</li>
<li>主从不一致，热点数据的频繁更新，如果在主从复制出现延迟的情况下，就会放大数据不一致的概率。</li>
</ol>
<h3 id="2-优化思路">2 优化思路</h3>
<p>这类问题的解决思路可以分为3类，分别是排队、拆分以及批次执行。</p>
<h4 id="思路-一排队">思路 一：排队</h4>
<p>排队方案要么是加锁，要么是单线程执行。<br>
如果能使用Redis的话，那么就可以利用他的高并发、单线程特点来解决这个问题。<br>
如果是使用数据库的话，可以使用优化版的云MySQL，腾讯云 MySQL 和阿里云 MySQL。<br>
他们都做了二次开发优化，系统会自动探测是否有单行的热点更新，让同一个热点行的更新语句，在执行层进行排队。这样的排队相比update的排队，要轻量级很多，因为他不需要自旋，不需要抢锁。</p>
<h4 id="思路二拆分用得不多">思路二：拆分（用得不多）</h4>
<p>类似分段锁机制，将一次扣减分散到不同的库表中进行，但可能存在碎片库存。</p>
<h4 id="思路三合并">思路三：合并</h4>
<p>把多个UPDATE合成一个UPDATE， 比如一个用户，有10个占用库存请求，每次占用1个，那么就可以提供一个批量占用的接口，让上游一次性把10个占用合并一起，这样数据库只需要做一次更新就行了</p>
<p>局限性：不是所有请求都可以合并的，有些场景，如电商的秒杀，用户需要很快的知道反馈，而批量执行就需要有个窗口来聚合，用户是不能接受这种等待窗口的。在一些异步链路上，可以用这种方案。<br>
<img src="https://github.com/PansonPanson/supply-chain/blob/main/%E4%BE%9B%E5%BA%94%E9%93%BE%E5%AD%90%E7%B3%BB%E7%BB%9F/%E6%99%BA%E8%83%BD%E4%BB%93%E5%82%A8%E7%B3%BB%E7%BB%9F/%E9%87%8D%E6%9E%84%E7%AF%87/assets/WES%20%E9%87%8D%E6%9E%84%E7%B3%BB%E5%88%97%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9AWES%20%E4%B8%89%E7%BA%A7%E5%BA%93%E5%AD%98%E6%A8%A1%E5%9E%8B/file-20251204214636292.png?raw=true" alt="" loading="lazy"></p>
<h2 id="57-学习互联网电商高并发库存扣减的思路">5.7、学习互联网电商高并发库存扣减的思路</h2>
<h3 id="1-两种方案">1 两种方案</h3>
<p>主流的有两种方案：</p>
<ol>
<li>数据库扣减：</li>
<li>redis 扣减：使用lua 脚本，先判断库存呢是否足够，足够再扣减</li>
</ol>
<h3 id="2-redis-库存的正确扣减">2 Redis 库存的正确扣减</h3>
<p>秒杀因为是一个高频的并发库存扣减的场景，所以，如何提升库存扣减的性能，并且保证他的准确性，这是一个在秒杀业务中极其重要的课题，稍有不慎就会带来超卖、少卖等问题。另外还需要关注一下对账的系统设计。<br>
具体的方案设计如下图：</p>
<figure data-type="image" tabindex="5"><img src="https://github.com/PansonPanson/supply-chain/blob/main/%E4%BE%9B%E5%BA%94%E9%93%BE%E5%AD%90%E7%B3%BB%E7%BB%9F/%E6%99%BA%E8%83%BD%E4%BB%93%E5%82%A8%E7%B3%BB%E7%BB%9F/%E9%87%8D%E6%9E%84%E7%AF%87/assets/WES%20%E9%87%8D%E6%9E%84%E7%B3%BB%E5%88%97%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9AWES%20%E4%B8%89%E7%BA%A7%E5%BA%93%E5%AD%98%E6%A8%A1%E5%9E%8B/%E7%A7%92%E6%9D%80%E5%B0%91%E5%8D%96.png?raw=true" alt="" loading="lazy"></figure>
<h3 id="3-redis保存库存的时候如何避免被redis清理掉">3  Redis保存库存的时候，如何避免被Redis清理掉？</h3>
<p>考的其实是 Redis 的内存淘汰策略。<br>
用 volatile 相关策略，这样只有设置了超时时间的才可能被淘汰。<br>
阿里云上的Redis的默认的淘汰策略是volatile-lru。<br>
腾讯云默认是noeviction。</p>
<h1 id="六-出库效率优化">六、出库效率优化</h1>
<h2 id="61-出库链路耗时在哪里">6.1、出库链路耗时在哪里？</h2>
<p>如果想优化出库正向链路，那么首先要知道耗时在哪些地方，这样才能对症下药。<br>
先回顾一下出库链路图：</p>
<figure data-type="image" tabindex="6"><img src="https://github.com/PansonPanson/supply-chain/blob/main/%E4%BE%9B%E5%BA%94%E9%93%BE%E5%AD%90%E7%B3%BB%E7%BB%9F/%E6%99%BA%E8%83%BD%E4%BB%93%E5%82%A8%E7%B3%BB%E7%BB%9F/%E9%87%8D%E6%9E%84%E7%AF%87/assets/WES%20%E9%87%8D%E6%9E%84%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%87%BA%E5%BA%93%E8%B0%83%E5%BA%A6%E6%AD%A3%E5%90%91%E9%93%BE%E8%B7%AF%E6%A2%B3%E7%90%86/file-20251122000925045.png?raw=true" alt="" loading="lazy"></figure>
<p>类似操作系统中磁盘 IO花费时间一般由 3 个部分组成：</p>
<ol>
<li>寻道时间</li>
<li>旋转延迟</li>
<li>数据传输时间</li>
</ol>
<p>这三者的时间都蛮长的，尤其是两者。为什么呢？因为涉及到物理移动。<br>
在出库链路中，耗时最长的也是如此，所以我们主要从这个方面入手。<br>
优化主要从两个方面来讨论，业务上优化以及技术上的优化。</p>
<h2 id="62-出库调度正向链路业务优化">6.2、出库调度正向链路业务优化</h2>
<h3 id="1-热度移位">1 热度移位</h3>
<p>在 WES（仓储执行系统）中， <strong>热度移位</strong>功能是一项智能的库存动态调整策略。其核心目标是让<strong>高频次出入库的商品</strong>（热销品）尽可能地靠近仓库的<strong>拣选工作站</strong>或<strong>出库区域</strong>，从而显著减少拣货员或自动化导引车（AGV）的行走或移动距离，最终提升整体仓储运营效率。</p>
<p>看一下热度移位前后对比图，应该比较清晰一些：</p>
<figure data-type="image" tabindex="7"><img src="https://github.com/PansonPanson/supply-chain/blob/main/%E4%BE%9B%E5%BA%94%E9%93%BE%E5%AD%90%E7%B3%BB%E7%BB%9F/%E6%99%BA%E8%83%BD%E4%BB%93%E5%82%A8%E7%B3%BB%E7%BB%9F/%E9%87%8D%E6%9E%84%E7%AF%87/assets/WES%20%E9%87%8D%E6%9E%84%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E5%87%BA%E5%BA%93%E8%B0%83%E5%BA%A6%E6%AD%A3%E5%90%91%E9%93%BE%E8%B7%AF%E6%95%88%E7%8E%87%E4%BC%98%E5%8C%96/file-20251122154308282.png?raw=true" alt="" loading="lazy"></figure>
<p>我们从图中可以看到，热度移位后，高频商品（红色部分）都移动到拣选工作站附近了。<br>
热度移位的目的本质是为了减少搬运时间，从而大幅提高出库效率。</p>
<h3 id="2-超-a-不返库">2 超 A 不返库</h3>
<p>智能仓的存储区是一个三维空间，热度移位更侧重水平坐标的优化，超 A 不返库则更侧重垂直坐标的优化。<br>
说的有点抽象，我简单解释一下。仓储区域是一个个的货架，货架分为多层，每一层又分为多个库位，最下层是缓存层，料箱容器如果放在货架上层，则需要从上层搬到下层，再从下层搬运到拣选工作站。<br>
超 A 不返库指的是高频超 A 商品放到货架最下面一层，也就是缓存层，减掉料箱从货架上层搬运到货架下层的流程。</p>
<p>文字可能不太好理解，我们看张图示意图吧：</p>
<figure data-type="image" tabindex="8"><img src="https://github.com/PansonPanson/supply-chain/blob/main/%E4%BE%9B%E5%BA%94%E9%93%BE%E5%AD%90%E7%B3%BB%E7%BB%9F/%E6%99%BA%E8%83%BD%E4%BB%93%E5%82%A8%E7%B3%BB%E7%BB%9F/%E9%87%8D%E6%9E%84%E7%AF%87/assets/WES%20%E9%87%8D%E6%9E%84%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E5%87%BA%E5%BA%93%E8%B0%83%E5%BA%A6%E6%AD%A3%E5%90%91%E9%93%BE%E8%B7%AF%E6%95%88%E7%8E%87%E4%BC%98%E5%8C%96/file-20251122205831266.png?raw=true" alt="" loading="lazy"></figure>
<h3 id="3-flowpick-单品单件">3 FlowPick 单品单件</h3>
<p>我们组负责的一些日本海外仓，比如 Eqseek，单据类型比较特殊，单品单件订单占比近80%，为提高拣选效率，可以一次入站完成更多件数，提出flowpick产品化方案。<br>
当然国内直播电商也有类似场景，比如直播间大主播，观众下单，大多是单品单件订单。<br>
WES对可聚合订单做标记，交由算法组，让算法把一批订单聚合分配到同一个 flowpick 槽位中。<br>
这样能大幅减少WES 调度和下游搬运次数。<br>
<img src="https://github.com/PansonPanson/supply-chain/blob/main/%E4%BE%9B%E5%BA%94%E9%93%BE%E5%AD%90%E7%B3%BB%E7%BB%9F/%E6%99%BA%E8%83%BD%E4%BB%93%E5%82%A8%E7%B3%BB%E7%BB%9F/%E9%87%8D%E6%9E%84%E7%AF%87/assets/WES%20%E9%87%8D%E6%9E%84%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E5%87%BA%E5%BA%93%E8%B0%83%E5%BA%A6%E6%AD%A3%E5%90%91%E9%93%BE%E8%B7%AF%E6%95%88%E7%8E%87%E4%BC%98%E5%8C%96/file-20251122220042503.png?raw=true" alt="" loading="lazy"></p>
<h3 id="4-进站提前上报">4 进站提前上报</h3>
<p>小车搬运容器即将进入工作站时，会减速，达到指定码点后，会上报到站消息。<br>
WES 拿到搬运系统上报的到站消息后，会推送实操任务给 STATION。<br>
我们做了提前上报功能，小车在即将进站前，到达指定码点时，就提前上报到站消息，让 WES 处理并推送实操任务，这样相当于做了并行处理：</p>
<ul>
<li>小车从指定码点到真正进站</li>
<li>WES 接收到站消息并推送实操任务<br>
这样也减少了出库链路时间。<br>
如下图所示：<br>
<img src="https://github.com/PansonPanson/supply-chain/blob/main/%E4%BE%9B%E5%BA%94%E9%93%BE%E5%AD%90%E7%B3%BB%E7%BB%9F/%E6%99%BA%E8%83%BD%E4%BB%93%E5%82%A8%E7%B3%BB%E7%BB%9F/%E9%87%8D%E6%9E%84%E7%AF%87/assets/WES%20%E9%87%8D%E6%9E%84%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E5%87%BA%E5%BA%93%E8%B0%83%E5%BA%A6%E6%AD%A3%E5%90%91%E9%93%BE%E8%B7%AF%E6%95%88%E7%8E%87%E4%BC%98%E5%8C%96/file-20251122221757555.png?raw=true" alt="" loading="lazy"></li>
</ul>
<h3 id="5-提前离站">5 提前离站</h3>
<p>原先的流程是拣选、封箱、点击全部分播完成后车才走，但其实拣选完之后，车就可以走了。<br>
提前离站我们做了开关，在拣选到最大值后，车提前离站，下一个车可以直接进站。<br>
这样我们又减少了一部分链路耗时。<br>
这里我也画了一张流程图，如下所示：<br>
<img src="https://github.com/PansonPanson/supply-chain/blob/main/%E4%BE%9B%E5%BA%94%E9%93%BE%E5%AD%90%E7%B3%BB%E7%BB%9F/%E6%99%BA%E8%83%BD%E4%BB%93%E5%82%A8%E7%B3%BB%E7%BB%9F/%E9%87%8D%E6%9E%84%E7%AF%87/assets/WES%20%E9%87%8D%E6%9E%84%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E5%87%BA%E5%BA%93%E8%B0%83%E5%BA%A6%E6%AD%A3%E5%90%91%E9%93%BE%E8%B7%AF%E6%95%88%E7%8E%87%E4%BC%98%E5%8C%96/file-20251122222552157.png?raw=true" alt="" loading="lazy"></p>
<h3 id="6-预出库">6 预出库</h3>
<p>那什么是预出库呢？我先聊一下问题背景，其实前文也聊了场景：<br>
料箱场景下的出库分为两段搬运：</p>
<ol>
<li><strong>C56 机器人：</strong> 将料箱搬运至<strong>缓存位</strong>。</li>
<li><strong>青鸾机器人：</strong> 将缓存位的料箱搬运至<strong>工作站</strong>。<br>
为了<strong>提高拣选效率</strong>，我们探讨了能否将第一段搬运（C56 搬运至缓存位）提前完成，即实现“预出库”。</li>
</ol>
<p>在料箱出库场景中，物料搬运分为两步：</p>
<ol>
<li>
<p><strong>C56 机器人：</strong> 将料箱搬运至<strong>缓存位</strong>。</p>
</li>
<li>
<p><strong>青鸾机器人：</strong> 将缓存位的料箱搬运至<strong>工作站</strong>。</p>
</li>
</ol>
<p>为了<strong>提高拣选效率</strong>，我们探讨了能否将第一段搬运（C56 搬运至缓存位）提前完成，即实现“预出库”。</p>
<p>我们提出了两种预出库方案：<strong>静态预出库</strong>和<strong>动态预出库</strong>。</p>
<h4 id="1-静态预出库-static-pre-outbound">1）. 静态预出库 (Static Pre-Outbound)</h4>
<table>
<thead>
<tr>
<th><strong>适用场景</strong></th>
<th><strong>客户在一天中某个特定时刻集中下发大部分订单。</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>方案描述</td>
<td>系统根据已下发订单所需的库存，<strong>提前</strong>将料箱搬运至缓存位。</td>
</tr>
<tr>
<td>优点</td>
<td><strong>简单易实施：</strong> 一天只需计算一次。</td>
</tr>
<tr>
<td>缺点</td>
<td>*需要严格控制订单的<strong>出库上墙顺序</strong>。 * 对<strong>缓存位占用较大</strong>。</td>
</tr>
</tbody>
</table>
<h4 id="2-动态预出库-dynamic-pre-outbound">2）. 动态预出库 (Dynamic Pre-Outbound)</h4>
<table>
<thead>
<tr>
<th><strong>适用场景</strong></th>
<th><strong>提升实时拣选效率，优化缓存资源占用。</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>方案描述</td>
<td>工作站<strong>虚拟出</strong>部分槽位用于分配“预出库订单”。  这些预出库订单仅执行<strong>第一段搬运</strong>（搬至缓存位）。 当实际订单完成后，对应的预出库订单才会转移到<strong>实际分播墙槽位</strong>上。</td>
</tr>
<tr>
<td>优点</td>
<td><strong>缓存位占用少</strong>，资源利用灵活。 对实际拣选效率提升<strong>显著</strong>。</td>
</tr>
<tr>
<td>缺点</td>
<td>需要<strong>实时计算</strong>和持续监控。 对<strong>系统资源消耗较大</strong>。</td>
</tr>
</tbody>
</table>
<h1 id="七-wes-调度模型">七、WES 调度模型</h1>
<p>我在前文聊过出库链路的大致链路流程。</p>
<p>但其实真实的出库调度链路远比这复杂，不仅涉及到库存模型、多样化的策略规则、配置、调度算法、热度算法，还涉及到单据任务调度以及相关的单据状态机、作业单状态机、任务状态机等等。</p>
<p>本文我将聊聊WES 的单据任务调度。</p>
<p>WES 这边的调度模型基本遵循三层：</p>
<ol>
<li>单据层：单据和单据明细</li>
<li>作业单层：作业单和作业单明细</li>
<li>任务层：包含命中的三级库存信息、容器、货架、库位</li>
</ol>
<p>从上到下，都是一对多的关系，以出库链路来说，一个出库单对应多个出库作业单，一个出库作业单对应多个出库任务。</p>
<h2 id="71-为什么要设计三层调度模型">7.1、为什么要设计三层调度模型？</h2>
<p>在一些小仓场景，仓内商品库存比较少，作业场景比较简单，其实作业单这一层是可以省略的，但我司的客户群体基本都是大仓，单仓过万平方，多库区，库存条目数过百万。如果只有调度任务这一层的话，无法精细化管理。比如出库单无法很好地表示库区维度的作业情况，哪些库区是有货的，哪些库区是无货的，哪些库区在作业了，哪些库区还没开始作业。</p>
<p>除了业务场景的考量，其实在模型含义上，直接使用上游下发的出库单来管理仓内作业流程，业务领域有些混淆了。出库单是上游的概念，出库单定义‘要什么’，而作业单定义‘怎么干’，关注的具体的执行层。</p>
<h2 id="72-单据-作业单-任务的状态流转">7.2、单据、作业单、任务的状态流转</h2>
<p>该部分信息有点涉敏，我简单聊聊。<br>
出库单是上游下发的单据，所以肯定有初始状态。<br>
提交出库单后，会预占二级库存并且生成出库作业单，出库作业单也有初始状态。<br>
出库作业单会经过复杂计算，并传给调度算法服务，最终 WES 会根据出库作业单与算法结果分配工作站、预占三级库存，并生成出库任务。<br>
同样的，出库任务也有初始状态。<br>
定时任务会流转，最终下发给下游的车辆调度系统，下发成功后，任务状态流转。<br>
车辆搬运中会不断上报任务调度实体，也就是小车的位置信息，到站后，调度任务状态变更。<br>
推完实操后，调度任务会变更为实操中。<br>
实操结束后，会变更为完成。</p>
<h2 id="73-调度的搬运优先级">7.3、调度的搬运优先级</h2>
<p>在履约链路中，会存在履约时效性的概念，在仓配场景中，简单来说就是，如何及时地把货物出库并配送到买家手中。</p>
<p>那上游下发的单据，可能就会带有履约时效性的信息，比如：</p>
<ol>
<li>单据优先级：优先级越高，调度任务的优先级也会根据权重提高优先级</li>
<li>期望发货时间：结合规则策略，动态根据期望发货时间提高优先级</li>
</ol>
<p>除了上游单据自带信息，在 WES 内部也会根据一些策略，去动态提高任务优先级，比如：</p>
<ol>
<li>按出库单持续时间：一个单子执行的时间越久，尾单部分，优先级就需要越高</li>
<li>按剩余拣选任务数：有的时候，上游希望剩余拣选任务数达到阈值后，能提高优先级。</li>
</ol>
<h2 id="74-库存分配优先级">7.4 库存分配优先级</h2>
<p>对于多库区精细化作业，需要具备按库区优先级来分配库存，比如存在 A、B 、C 库区，希望先把 A 库区的库存先出掉，再出 B、C 库区的库存。<br>
同样的，这个能力也是需要提供规则策略动态配置能力的。</p>
<h1 id="八-与第三方系统交互数据一致性保障">八、与第三方系统交互数据一致性保障</h1>
<h2 id="81-wes-与第三方系统数据不一致困境">8.1、WES 与第三方系统数据不一致困境</h2>
<p>首先说一下智能仓储系统的场景：智能仓储系统的核心链路涉及多个系统，但是对于数据最终一致性有要求，且部分场景需要提供补偿机制。</p>
<p>我们需要与诸多二方系统和三方系统对接，比如：<br>
1、车辆调度系统，可能就会遇到：</p>
<ul>
<li>车不来：下发调度信息的时候，消息发送失败，导致车辆不来</li>
<li>来错车：下发调度信息的时候，消息乱序，导致来错车</li>
<li>车不走：下发车辆离站消息的时候，消息发送失败，导致车辆不走</li>
</ul>
<p>2、与算法服务对接</p>
<ul>
<li>离线任务下发失败</li>
<li>调用算法计算热度</li>
</ul>
<p>3、与外设系统交互，可能会遇到：</p>
<ul>
<li>
<p>灯不亮：</p>
<ul>
<li>发送亮灯消息的时候，消息发送失败，导致外设系统未接收到消息，灯不亮</li>
<li>外设系统与物理设备交互，调用相关接口失败</li>
</ul>
</li>
<li>
<p>灯不灭：</p>
<ul>
<li>发送灭灯消息的时候，消息发送失败，导致外设系统未接收到消息，灯不灭</li>
<li>外设系统与物理设备交互，调用相关接口失败，灯不灭</li>
</ul>
</li>
<li>
<p>亮错灯：</p>
<ul>
<li>发送亮灯消息的时候，消息乱序，导致外设系统亮灯错乱</li>
</ul>
</li>
</ul>
<p>4、与打印系统交互，可能会遇到：</p>
<ul>
<li>没打印：接口调用失败，导致单据打印失败</li>
</ul>
<p>5、与上游系统交互：</p>
<ul>
<li>各种单据的实操结果未正常反馈上游
<ul>
<li>出库单按单反馈</li>
<li>出库单按箱反馈</li>
<li>入库单按单反馈</li>
<li>入库单按箱反馈</li>
<li>盘点单按单反馈</li>
<li>库存调整单按单反馈</li>
<li>……<br>
6、与基础数据系统交互</li>
</ul>
</li>
<li>货架热度计算结果更新失败</li>
<li>料箱热度计算结果更新失败</li>
<li>容器位置更新<br>
<img src="https://github.com/PansonPanson/supply-chain/blob/main/%E4%BE%9B%E5%BA%94%E9%93%BE%E5%AD%90%E7%B3%BB%E7%BB%9F/%E6%99%BA%E8%83%BD%E4%BB%93%E5%82%A8%E7%B3%BB%E7%BB%9F/%E9%87%8D%E6%9E%84%E7%AF%87/image/7/file-20251129203301152.png?raw=true" alt="" loading="lazy"><br>
这些场景无法使用本地事务实现，因为是分布式系统。有些场景也不能纯用 MQ 的消息事务实现，因为 RocketMQ 事务消息重试机制不灵活。</li>
</ul>
<h2 id="82-关于重试逻辑的思考">8.2、关于重试逻辑的思考</h2>
<p>一个健壮的系统是需要考虑关键节点的稳定性的，以与外部系统交互这种节点来讨论，我觉得核心的意识是不相信第三方系统，无论是数据的获取还是推送。</p>
<p>所以需要实现重试逻辑。</p>
<p>但二方系统、三方系统有许多，如果在每一个节点都去写重试逻辑，那么重试逻辑就会变得不可复用。比如说：</p>
<ul>
<li>重试次数怎么设置？</li>
<li>每次重试的间隔如何考虑？</li>
<li>重试逻辑是否影响主线程，需要异步化吗？</li>
<li>是否考虑加降级呢？</li>
<li>能不能加告警？</li>
<li>……</li>
</ul>
<h2 id="83-抽象-复用与便捷">8.3、抽象、复用与便捷</h2>
<p>考虑以上问题后，我在阅读了转转和得物的关于重试组件的技术博客后，开始有了新的思考。是不是可以抽取出业务需求，自定义一个 springboot starter，用户只需要引入这个 maven 包，做一些简单的配置和适配，就可以做到关键节点的自动重试呢？</p>
<p>很幸运，我在网上找了一些类似的教程和代码，结合得物、转转的技术博客，实现了这个组件。</p>
<p>我们可以基于SpringAOP来实现，将需要重试的逻辑抽取成 public 修饰的方法，在这个方法上加上一致性注解。<br>
拦截所有加了一致性注解的方法，封装为一个重试任务，持久化到数据库中，再通过反射去执行这个任务。</p>
<figure data-type="image" tabindex="9"><img src="https://github.com/PansonPanson/supply-chain/blob/main/%E4%BE%9B%E5%BA%94%E9%93%BE%E5%AD%90%E7%B3%BB%E7%BB%9F/%E6%99%BA%E8%83%BD%E4%BB%93%E5%82%A8%E7%B3%BB%E7%BB%9F/%E9%87%8D%E6%9E%84%E7%AF%87/image/7/chongshizujian.png?raw=true" alt="" loading="lazy"></figure>
<h2 id="84-如何设计自定义注解">8.4、如何设计自定义注解</h2>
<p>我们如果想基于反射来做，那注解必须要有反射相关的信息，另外还要有执行间隔、延迟时间、告警相关<br>
降级相关。</p>
<ol>
<li>任务名称：默认取方法全限定名，因为想使用反射来执行</li>
<li>执行间隔：任务执行间隔</li>
<li>初始延迟时间</li>
<li>告警表达式</li>
<li>告警类</li>
<li>降级类</li>
<li>……</li>
</ol>
<h2 id="85-重试任务执行流程">8.5、重试任务执行流程</h2>
<p>如下图所示：<br>
<img src="https://github.com/PansonPanson/Argo/blob/main/doc/image/%E6%B5%81%E7%A8%8B%E8%AE%BE%E8%AE%A1.png?raw=true" alt="" loading="lazy"></p>
<h2 id="86-如何自定义任务查询逻辑">8.6、如何自定义任务查询逻辑</h2>
<p>任务失败重试是通过定时任务调⽤ <code>taskScheduleManager.performanceTask()</code> ⽅法来实现 的，底层逻辑就是根据条件从数据库中查询出来失败的任务，然后判 断是否需要重试，执行后续逻辑。</p>
<p>在这个过程中，根据条件查询失败的任务，这⾥的条件允许⼀定程度的⾃定义。默认情况下⾏为 是： <strong>每次查询当前时间 - 1⼩时 时间范围内的1000条失败的记录</strong>。</p>
<p>如果想要更改此逻辑，可以自定义查询类名并继承查询接口，然后在 yml 中配置全路径类名，组件接入启动时会根据自定义配置类来反射获取自定义查询配置信息。<br>
<img src="https://raw.githubusercontent.com/PansonPanson/supply-chain/refs/heads/main/%E4%BE%9B%E5%BA%94%E9%93%BE%E5%AD%90%E7%B3%BB%E7%BB%9F/%E6%99%BA%E8%83%BD%E4%BB%93%E5%82%A8%E7%B3%BB%E7%BB%9F/%E9%87%8D%E6%9E%84%E7%AF%87/image/7/file-20251129204320270.png" alt="" loading="lazy"></p>
<h2 id="87-指数退避重试">8.7、指数退避重试</h2>
<p>指数退避重试是一种智能的容错机制，其核心思想是当操作失败后，重试的等待时间随着重试次数的增加而呈指数级增长，并通常会引入随机扰动。它能有效防止因频繁重试导致的系统压力激增，是构建稳定分布式系统和网络应用的关键策略。</p>
<table>
<thead>
<tr>
<th>重试次数</th>
<th>基础延迟计算（示例）</th>
<th>实际等待时间（含抖动）</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>第1次重试</td>
<td><code>base_delay * (2^0) = 1s</code></td>
<td>1秒 ± 随机时间</td>
<td>初始快速重试，希望问题已瞬时恢复</td>
</tr>
<tr>
<td>第2次重试</td>
<td><code>base_delay * (2^1) = 2s</code></td>
<td>2秒 ± 随机时间</td>
<td>延迟加倍，给系统更多恢复时间</td>
</tr>
<tr>
<td>第3次重试</td>
<td><code>base_delay * (2^2) = 4s</code></td>
<td>4秒 ± 随机时间</td>
<td>继续指数增长，进一步退让</td>
</tr>
<tr>
<td>第n次重试</td>
<td><code>base_delay * (2^(n-1))</code></td>
<td>计算结果 ± 随机时间，但不超过 <code>max_delay</code></td>
<td>避免等待时间无限增长</td>
</tr>
<tr>
<td>在计算下一次执行时间时，可以按照这个指数退避重试，但一般我们设置的重试次数都很小，所以与线性重试差距不大。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><img src="" alt="" loading="lazy"></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="88-降级逻辑设计">8.8、降级逻辑设计</h2>
<p>有时候我们希望重试失败之后进行降级处理，所以注解中要支持定义降级类。<br>
如果配置了降级类，并且超过了重试次数阈值，就调用降级逻辑。<br>
具体的实现方式就是通过反射调用指定降级类的同名方法，方法参数要与原方法一致。</p>
<h2 id="89-告警逻辑">8.9、告警逻辑</h2>
<p>告警逻辑可以自定义，在注解上可以配置自定义告警类，如果触发告警规则，则通过反射调用告警类的告警方法。<br>
因为告警可能会比较耗时，所以做了异步化，避免影响主线程。</p>
<h2 id="810-如何设计重试任务表">8.10、如何设计重试任务表</h2>
<p><strong>数据模型：argo_task（任务表）</strong></p>
<table>
<thead>
<tr>
<th>字段名 (Field Name)</th>
<th>数据类型 (Data Type)</th>
<th>允许空值 (Nullable)</th>
<th>默认值 (Default)</th>
<th>注释 (Comment)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>id</strong>​</td>
<td>bigint</td>
<td>NOT NULL</td>
<td>AUTO_INCREMENT</td>
<td>主键自增</td>
</tr>
<tr>
<td><strong>task_id</strong>​</td>
<td>varchar(500)</td>
<td>NOT NULL</td>
<td>-</td>
<td>用户自定义的任务名称，如果没有则使用方法签名</td>
</tr>
<tr>
<td><strong>task_status</strong>​</td>
<td>int</td>
<td>NOT NULL</td>
<td>0</td>
<td>执行状态</td>
</tr>
<tr>
<td><strong>execute_times</strong>​</td>
<td>int</td>
<td>NOT NULL</td>
<td>-</td>
<td>执行次数</td>
</tr>
<tr>
<td><strong>execute_time</strong>​</td>
<td>bigint</td>
<td>NOT NULL</td>
<td>-</td>
<td>执行时间</td>
</tr>
<tr>
<td><strong>parameter_types</strong>​</td>
<td>varchar(255)</td>
<td>NOT NULL</td>
<td>-</td>
<td>参数的类路径名称</td>
</tr>
<tr>
<td><strong>method_name</strong>​</td>
<td>varchar(100)</td>
<td>NOT NULL</td>
<td>-</td>
<td>方法名</td>
</tr>
<tr>
<td><strong>method_sign_name</strong>​</td>
<td>varchar(200)</td>
<td>NOT NULL</td>
<td>''</td>
<td>方法签名</td>
</tr>
<tr>
<td><strong>execute_interval_sec</strong>​</td>
<td>int</td>
<td>NOT NULL</td>
<td>60</td>
<td>执行间隔秒</td>
</tr>
<tr>
<td><strong>delay_time</strong>​</td>
<td>int</td>
<td>NOT NULL</td>
<td>60</td>
<td>延迟时间：单位秒</td>
</tr>
<tr>
<td><strong>task_parameter</strong>​</td>
<td>varchar(200)</td>
<td>NOT NULL</td>
<td>''</td>
<td>任务参数</td>
</tr>
<tr>
<td><strong>performance_way</strong>​</td>
<td>int</td>
<td>NOT NULL</td>
<td>-</td>
<td>执行模式：1、立即执行 2、调度执行</td>
</tr>
<tr>
<td><strong>thread_way</strong>​</td>
<td>int</td>
<td>NOT NULL</td>
<td>-</td>
<td>线程模型 1、异步 2、同步</td>
</tr>
<tr>
<td><strong>error_msg</strong>​</td>
<td>varchar(200)</td>
<td>NOT NULL</td>
<td>''</td>
<td>执行的error信息</td>
</tr>
<tr>
<td><strong>alert_expression</strong>​</td>
<td>varchar(100)</td>
<td>YES</td>
<td>NULL</td>
<td>告警表达式</td>
</tr>
<tr>
<td><strong>alert_action_bean_name</strong>​</td>
<td>varchar(255)</td>
<td>YES</td>
<td>NULL</td>
<td>告警逻辑的执行beanName</td>
</tr>
<tr>
<td><strong>fallback_class_name</strong>​</td>
<td>varchar(255)</td>
<td>YES</td>
<td>NULL</td>
<td>降级逻辑的类路径</td>
</tr>
<tr>
<td><strong>fallback_error_msg</strong>​</td>
<td>varchar(200)</td>
<td>YES</td>
<td>NULL</td>
<td>降级失败时的错误信息</td>
</tr>
<tr>
<td><strong>shard_key</strong>​</td>
<td>bigint</td>
<td>YES</td>
<td>0</td>
<td>任务分片键</td>
</tr>
<tr>
<td><strong>gmt_create</strong>​</td>
<td>datetime</td>
<td>NOT NULL</td>
<td>-</td>
<td>创建时间</td>
</tr>
<tr>
<td><strong>gmt_modified</strong>​</td>
<td>datetime</td>
<td>NOT NULL</td>
<td>-</td>
<td>修改时间</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p><strong>主键 (Primary Key)</strong>：<code>PRIMARY KEY (id)</code>。</p>
</li>
<li>
<p><strong>唯一索引 (Unique Key)</strong>：<code>UNIQUE KEY uk_id_shard_key (id, shard_key) USING BTREE</code>。这是一个复合唯一索引，确保了 <code>id</code>和 <code>shard_key</code>组合的唯一性，常用于分库分表场景。</p>
</li>
<li>
<p><strong>存储引擎与字符集 (Storage Engine &amp; Character Set)</strong>：<code>ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci</code>。使用InnoDB引擎，字符集为支持更广范围字符（如emoji）的utf8mb4。</p>
</li>
</ul>
<h1 id="九-wes-内部系统数据一致性保障">九、WES 内部系统数据一致性保障</h1>
<p>我在现司的很长一段时间里一直被现场问题工单 oncall 弄得痛不欲生，大概有半年多，我司很多第三方仓，尤其是海外仓，跨时区工作，经常半夜打我电话，一起床又是一个通宵。坦诚来说，工作这么多年，在我司的前半段时间工作，是我职业生涯中最痛苦的一段时间，捂头哈哈~</p>
<p>这段经历让我切身体会到：<strong>当核心履约链路缺乏系统性设计时，稳定性问题最终一定会以“人工成本”的形式被偿还。</strong></p>
<p>后来，在一位在公司深耕十年的前辈建议和引荐下，我转入产品线团队，参与 WES 系统的重构工作，也正是在这一过程中，我开始系统性地审视出库链路，并逐步引入 Saga 思想来解决长期存在的履约一致性问题。</p>
<p>收获良多，我很感谢他。</p>
<figure data-type="image" tabindex="10"><img src="https://images.unsplash.com/photo-1755109604669-2719abfbe5b6?q=80&amp;w=2777&amp;auto=format&amp;fit=crop&amp;ixlib=rb-4.1.0&amp;ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D" alt="" loading="lazy"></figure>
<p>在仓储系统中，出库履约是一条<strong>跨系统、跨资源、长生命周期</strong>的业务链路，涉及到状态机、库存模型、调度模型、规则配置等等。本文结合我过往在 WES（Warehouse Execution System）中的工程实践，分享出库链路中落地 Saga 的思考、演进过程与经验总结。</p>
<hr>
<h2 id="91-仓储业务名词解释">9.1、仓储业务名词解释</h2>
<p>为了便于不同业务领域背景的朋友能理解本文的一些内容，加了一些名词说明。</p>
<figure data-type="image" tabindex="11"><img src="https://github.com/PansonPanson/supply-chain/blob/main/%E4%BE%9B%E5%BA%94%E9%93%BE%E5%AD%90%E7%B3%BB%E7%BB%9F/%E6%99%BA%E8%83%BD%E4%BB%93%E5%82%A8%E7%B3%BB%E7%BB%9F/%E9%87%8D%E6%9E%84%E7%AF%87/assets/WES%20%E9%87%8D%E6%9E%84%E7%B3%BB%E5%88%97%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E5%87%BA%E5%BA%93%E9%93%BE%E8%B7%AF%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%20Saga%20%E5%AE%9E%E8%B7%B5/file-20251213233756392.png?raw=true" alt="" loading="lazy"></figure>
<h3 id="1-出库单">1. 出库单</h3>
<p>出库单本质上是上游下发的单据，比如你在淘宝上买了 2 个牙刷，3 件毛巾。那上游（可能是 OMS、WMS）会下发一个出库单到 WES 来，告知 WES 我现在要出货配送 2 个牙刷、3 件毛巾。出库单就是用来表达要出库的商品信息。</p>
<p>在数据模型上，出库单分为主体和明细。</p>
<h3 id="2-出库作业单">2. 出库作业单</h3>
<p>出库作业单某种层面上是根据出库单做的一层解耦单据，将具体的执行层与上游下发的单据层隔离开。</p>
<p>另一个维度来理解的话，是按库区维度对出库单做了一次拆单。</p>
<p>出库作业单单也有主体和明细。比如说上文的出库单，可能会分裂成两个出库单，A 库区出库 2 件牙刷，B 库区出库 3 件毛巾。</p>
<h3 id="3-出库任务">3. 出库任务</h3>
<p>出库任务业务含义上表示要从某个存储库位（货架库位、料箱、料格）中出库某个包装批次的商品。</p>
<p>WES 会对这个出库任务做一层转换，加上搬运调度层的含义，比如要把这个商品放到哪个工作站的那个槽位上去拣选，搬运的目的地是哪里。</p>
<h3 id="4二级库存">4.二级库存</h3>
<p>库区层面的库存，智能仓分为多个库区，二级库存是库区维度商品批次库存。</p>
<h3 id="5三级库存">5.三级库存</h3>
<p>库位维度的库存，实际的存储库存，比二级库存会更细粒度一些。</p>
<h2 id="92-背景为什么出库履约是一个长事务问题">9.2、背景：为什么出库履约是一个“长事务”问题</h2>
<p>在 WES 中，一次出库并非一个同步完成的动作，而是由多个阶段逐步推进：</p>
<ul>
<li>
<p>上游系统下发出库单</p>
</li>
<li>
<p>根据规则拆分出库单生成出库作业单，预占二级库存</p>
</li>
<li>
<p>与算法服务交互，分配工作站槽位</p>
</li>
<li>
<p>与算法服务交互，分配三级库存，生成并下发搬运任务</p>
</li>
<li></li>
<li>
<p>将调度任务下发至下游搬运集群</p>
</li>
<li>
<p>小车到站推送拣选实操</p>
</li>
<li>
<p>实操反馈，扣减二三级库存，完结作业单、任务，小车离站</p>
</li>
</ul>
<figure data-type="image" tabindex="12"><img src="https://github.com/PansonPanson/supply-chain/blob/main/%E4%BE%9B%E5%BA%94%E9%93%BE%E5%AD%90%E7%B3%BB%E7%BB%9F/%E6%99%BA%E8%83%BD%E4%BB%93%E5%82%A8%E7%B3%BB%E7%BB%9F/%E9%87%8D%E6%9E%84%E7%AF%87/assets/WES%20%E9%87%8D%E6%9E%84%E7%B3%BB%E5%88%97%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E5%87%BA%E5%BA%93%E9%93%BE%E8%B7%AF%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%20Saga%20%E5%AE%9E%E8%B7%B5/file-20251213234238868.png?raw=true" alt="" loading="lazy"></figure>
<p>这一过程具备几个典型特征：</p>
<ul>
<li>
<p>涉及多个本地事务</p>
</li>
<li>
<p>业务链路长，状态中间态多</p>
</li>
<li>
<p>允许失败、需要回滚和重试</p>
</li>
<li>
<p>对可用性要求高，不追求强一致</p>
</li>
</ul>
<p>这使得传统的强一致分布式事务（如 XA / 2PC）在该场景下并不适用。</p>
<hr>
<h2 id="93-saga-原理回顾结合我个人的工程视角">9.3、Saga 原理回顾（结合我个人的工程视角）</h2>
<h3 id="1-什么是-saga">1. 什么是 Saga</h3>
<p>Saga 是一种用于解决<strong>分布式长事务</strong>的问题模型，其核心思想是：</p>
<ul>
<li>
<p>将一个全局事务拆分为多个<strong>可独立提交的本地事务</strong></p>
</li>
<li>
<p>每个本地事务都对应一个<strong>补偿操作</strong></p>
</li>
<li>
<p>通过正向执行与必要时的补偿执行，最终达成一致状态</p>
</li>
</ul>
<p>Saga 的目标不是“永不失败”，而是：</p>
<blockquote>
<p><strong>在允许中间不一致的前提下，最终回到一个业务可接受的状态</strong>。</p>
</blockquote>
<hr>
<h3 id="2-编排型-saga-vs-协同型-saga">2. 编排型 Saga vs 协同型 Saga</h3>
<p>Saga 通常分为两类：</p>
<ul>
<li>
<p><strong>协同型（Choreography）</strong>：各参与方通过事件协作推进</p>
</li>
<li>
<p><strong>编排型（Orchestration）</strong>：由一个中心节点统一编排流程</p>
</li>
</ul>
<figure data-type="image" tabindex="13"><img src="https://github.com/PansonPanson/supply-chain/blob/main/%E4%BE%9B%E5%BA%94%E9%93%BE%E5%AD%90%E7%B3%BB%E7%BB%9F/%E6%99%BA%E8%83%BD%E4%BB%93%E5%82%A8%E7%B3%BB%E7%BB%9F/%E9%87%8D%E6%9E%84%E7%AF%87/assets/WES%20%E9%87%8D%E6%9E%84%E7%B3%BB%E5%88%97%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E5%87%BA%E5%BA%93%E9%93%BE%E8%B7%AF%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%20Saga%20%E5%AE%9E%E8%B7%B5/file-20251213234323066.png?raw=true" alt="" loading="lazy"></figure>
<p>在 WES 出库场景中，我们选择的是：</p>
<blockquote>
<p><strong>以出库单为业务目标的编排型 Saga</strong></p>
</blockquote>
<p>原因很简单：</p>
<ul>
<li>
<p>WES 本身就是履约编排中枢</p>
</li>
<li>
<p>下游系统（如 WCS）不具备事务补偿能力</p>
</li>
<li>
<p>需要明确、可控的流程推进与回滚逻辑</p>
</li>
</ul>
<hr>
<h2 id="94-wes-出库-saga-的业务建模">9.4、WES 出库 Saga 的业务建模</h2>
<h3 id="1-saga-的业务边界">1. Saga 的业务边界</h3>
<ul>
<li>
<p><strong>Saga 实例粒度</strong>：出库单</p>
</li>
<li>
<p><strong>Saga 目标</strong>：完成一次出库履约（成功或可控失败）</p>
</li>
</ul>
<p>出库单天然就是一个 Saga 的生命周期边界。</p>
<hr>
<h3 id="2-核心业务对象">2. 核心业务对象</h3>
<ul>
<li>
<p>出库单（Outbound Order）</p>
</li>
<li>
<p>出库作业单（Work ）</p>
</li>
<li>
<p>出库任务（Job）</p>
</li>
<li>
<p>二级库存（L2，逻辑库存）</p>
</li>
<li>
<p>三级库存（L3，具体到库位库存）</p>
</li>
<li>
<p>工作站 / WCS</p>
</li>
</ul>
<p>这些对象的<strong>状态变化</strong>，共同构成了 Saga 的执行轨迹。</p>
<hr>
<h2 id="95-saga-的正向履约流程">9.5、Saga 的正向履约流程</h2>
<figure data-type="image" tabindex="14"><img src="https://github.com/PansonPanson/supply-chain/blob/main/%E4%BE%9B%E5%BA%94%E9%93%BE%E5%AD%90%E7%B3%BB%E7%BB%9F/%E6%99%BA%E8%83%BD%E4%BB%93%E5%82%A8%E7%B3%BB%E7%BB%9F/%E9%87%8D%E6%9E%84%E7%AF%87/assets/WES%20%E9%87%8D%E6%9E%84%E7%B3%BB%E5%88%97%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E5%87%BA%E5%BA%93%E9%93%BE%E8%B7%AF%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%20Saga%20%E5%AE%9E%E8%B7%B5/file-20251213234432552.png?raw=true" alt="" loading="lazy"></figure>
<p>几个关键点：</p>
<ul>
<li>
<p>Saga 并不是同步完成，而是被<strong>定时器持续推进</strong></p>
</li>
<li>
<p>每一步都是独立本地事务</p>
</li>
<li>
<p>任意一步失败，都不会影响已提交步骤的可见性</p>
</li>
</ul>
<hr>
<h2 id="96-外部事件驱动的-saga工作站下线">9.6、外部事件驱动的 Saga：工作站下线</h2>
<p>在真实仓储环境中，<strong>资源变化是常态</strong>。</p>
<h3 id="1-典型场景工作站下线">1. 典型场景：工作站下线</h3>
<p>当某个工作站下线时：</p>
<ul>
<li>
<p>已生成但未执行的任务不可继续</p>
</li>
<li>
<p>已预占的三级库存需要释放</p>
</li>
<li>
<p>原有作业规划失效，需要重新规划</p>
</li>
</ul>
<hr>
<h3 id="2-我们的处理方式">2. 我们的处理方式</h3>
<p>在 Saga 视角下，这不是“异常兜底”，而是：</p>
<blockquote>
<p><strong>一次由外部事件触发的补偿 + 重编排流程</strong></p>
</blockquote>
<p>具体行为：</p>
<figure data-type="image" tabindex="15"><img src="https://github.com/PansonPanson/supply-chain/blob/main/%E4%BE%9B%E5%BA%94%E9%93%BE%E5%AD%90%E7%B3%BB%E7%BB%9F/%E6%99%BA%E8%83%BD%E4%BB%93%E5%82%A8%E7%B3%BB%E7%BB%9F/%E9%87%8D%E6%9E%84%E7%AF%87/assets/WES%20%E9%87%8D%E6%9E%84%E7%B3%BB%E5%88%97%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E5%87%BA%E5%BA%93%E9%93%BE%E8%B7%AF%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%20Saga%20%E5%AE%9E%E8%B7%B5/file-20251213234525239.png?raw=true" alt="" loading="lazy"></figure>
<p>Saga 在这里体现的是<strong>业务韧性</strong>。</p>
<hr>
<h2 id="97-saga-的工程落地方式">9.7、Saga 的工程落地方式</h2>
<figure data-type="image" tabindex="16"><img src="https://github.com/PansonPanson/supply-chain/blob/main/%E4%BE%9B%E5%BA%94%E9%93%BE%E5%AD%90%E7%B3%BB%E7%BB%9F/%E6%99%BA%E8%83%BD%E4%BB%93%E5%82%A8%E7%B3%BB%E7%BB%9F/%E9%87%8D%E6%9E%84%E7%AF%87/assets/WES%20%E9%87%8D%E6%9E%84%E7%B3%BB%E5%88%97%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E5%87%BA%E5%BA%93%E9%93%BE%E8%B7%AF%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%20Saga%20%E5%AE%9E%E8%B7%B5/file-20251213234621384.png?raw=true" alt="" loading="lazy"></figure>
<h3 id="1-状态机-定时器轻量级-saga-driver">1. 状态机 + 定时器：轻量级 Saga Driver</h3>
<p>我们没有引入专门的工作流或 Saga 框架，而是采用：</p>
<ul>
<li>
<p><strong>状态机</strong>：描述“当前处于哪一步”</p>
</li>
<li>
<p><strong>定时器</strong>：负责推进下一步执行</p>
</li>
</ul>
<p>这种方式：</p>
<ul>
<li>
<p>实现简单</p>
</li>
<li>
<p>易于调试</p>
</li>
<li>
<p>与业务模型高度贴合</p>
</li>
</ul>
<hr>
<h3 id="2-工作站维度的分布式锁">2. 工作站维度的分布式锁</h3>
<p>我们在工程上引入了：</p>
<blockquote>
<p><strong>以工作站为粒度的分布式锁</strong></p>
</blockquote>
<p>使用原则非常明确：</p>
<ul>
<li>
<p>锁只用于<strong>并发收敛</strong></p>
</li>
<li>
<p>不承担 Saga 一致性语义</p>
</li>
</ul>
<p>典型使用场景：</p>
<ul>
<li>
<p>生成任务</p>
</li>
<li>
<p>回滚任务</p>
</li>
<li>
<p>下发任务</p>
</li>
<li>
<p>处理工作站下线事件</p>
</li>
</ul>
<p>并且严格遵循：</p>
<blockquote>
<p><strong>锁内逻辑原子化：先提交事务，再释放锁</strong></p>
</blockquote>
<hr>
<h2 id="98-saga-的可观测性任务流转树监控">9.8、Saga 的可观测性：任务流转树监控</h2>
<p>Saga 最大的工程风险，不是失败，而是：</p>
<blockquote>
<p><strong>流程卡死却不可见</strong>。</p>
</blockquote>
<p>为此，我们构建了一套<strong>任务流转树监控系统</strong>。</p>
<h3 id="能看到什么">能看到什么？</h3>
<ul>
<li>
<p>一个出库单下：</p>
</li>
<li>
<p>出库明细的信息</p>
</li>
<li>
<p>分裂成了多少作业单</p>
</li>
<li>
<p>每个作业单生成了多少任务</p>
</li>
<li>
<p>每个 Work / Task：</p>
</li>
<li>
<p>当前状态</p>
</li>
<li>
<p>状态的业务含义</p>
</li>
<li>
<p>在当前状态停留的时长</p>
</li>
</ul>
<figure data-type="image" tabindex="17"><img src="https://github.com/PansonPanson/supply-chain/blob/main/%E4%BE%9B%E5%BA%94%E9%93%BE%E5%AD%90%E7%B3%BB%E7%BB%9F/%E6%99%BA%E8%83%BD%E4%BB%93%E5%82%A8%E7%B3%BB%E7%BB%9F/%E9%87%8D%E6%9E%84%E7%AF%87/assets/WES%20%E9%87%8D%E6%9E%84%E7%B3%BB%E5%88%97%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E5%87%BA%E5%BA%93%E9%93%BE%E8%B7%AF%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%20Saga%20%E5%AE%9E%E8%B7%B5/file-20251214000534125.png?raw=true" alt="" loading="lazy"></figure>
<p>这使得 Saga 从“黑盒流程”变成了“白盒履约”。</p>
<hr>
<h2 id="99-我们踩过的坑-为什么没选-tcc">9.9、我们踩过的坑 &amp; 为什么没选 TCC</h2>
<h3 id="1-我们踩过的几个坑">1. 我们踩过的几个坑</h3>
<ul>
<li>
<p><strong>把异常当成少数情况</strong>：在仓储系统中，异常本身就是常态</p>
</li>
<li>
<p><strong>过早追求强一致</strong>：导致系统复杂度和耦合度急剧上升</p>
</li>
<li>
<p><strong>缺乏可观测性</strong>：问题只能靠日志和人工猜测</p>
</li>
</ul>
<hr>
<h3 id="2-为什么没选-tcc">2. 为什么没选 TCC</h3>
<p>我们认真评估过 TCC，但最终没有采用，原因包括：</p>
<ul>
<li>
<p>Try 阶段需要资源强锁定，不适合长时间履约</p>
</li>
<li>
<p>下游系统（如 WCS）不具备 Confirm / Cancel 能力</p>
</li>
<li>
<p>TCC 对接口侵入性极强，演进成本高</p>
</li>
</ul>
<p>相比之下，Saga：</p>
<ul>
<li>
<p>更符合“最终一致”的业务现实</p>
</li>
<li>
<p>对下游侵入小</p>
</li>
<li>
<p>更易与现有系统演进融合</p>
</li>
</ul>
<hr>
<h2 id="910-总结">9.10、总结</h2>
<p>我们并不是“为了 Saga 而 Saga”，而是在解决 WES 出库问题的过程中，逐步演进出了一套 Saga 实践方案。</p>
<ul>
<li>
<p>以出库单为业务目标</p>
</li>
<li>
<p>以状态机 + 定时器驱动</p>
</li>
<li>
<p>支持外部事件补偿</p>
</li>
<li>
<p>强调最终一致性与可观测性</p>
</li>
</ul>
<p>这套方案没有追求概念上的完美，但在真实复杂业务中，<strong>稳定、可控、可演进</strong>，我觉得<strong>这，才是 Saga 在工程实践中的真正价值。</strong></p>
<h1 id="十-库存对账设计">十、库存对账设计</h1>
<h1 id="十一-策略规则治理">十一、策略规则治理</h1>
<p>WES 系统重构前，总代码行数接近八十多万，在这八十多万行代码中，既存在非常多的重复逻辑，又存在非常多的变化逻辑，前者可以通过不断地抽取公共逻辑来达到去重、瘦身的效果。</p>
<p>后者的治理则更为复杂一些，需要做很多抽象与统一整合，也就是策略规则。</p>
<p>坦诚来说，重构之前对规则引擎一点都不了解，自己也是在不断地接触和学习，扩宽自己的技术栈广度。回过头来，发现做重构确实让自己成长得很快。</p>
<h3 id="1-正视复杂性wes-业务规则的多与变">1、正视复杂性：WES 业务规则的“多”与“变”</h3>
<p><img src="https://github.com/PansonPanson/supply-chain/blob/main/%E4%BE%9B%E5%BA%94%E9%93%BE%E5%AD%90%E7%B3%BB%E7%BB%9F/%E6%99%BA%E8%83%BD%E4%BB%93%E5%82%A8%E7%B3%BB%E7%BB%9F/%E9%87%8D%E6%9E%84%E7%AF%87/assets/WES%20%E9%87%8D%E6%9E%84%E7%B3%BB%E5%88%97%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E5%A4%8D%E6%9D%82%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E8%A7%84%E5%88%99/file-20251206191038018.png?raw=true" alt="" loading="lazy"><br>
在深入技术选型之前，我们首先要清晰地定义问题。WES 作为仓储执行的入口，其核心复杂度在于其需要应对B 端多变且相互交织的业务规则。这些规则直接体现了不同客户、不同业务场景下的运营策略。</p>
<ul>
<li>
<p><strong>规则的维度多</strong>：仅出库环节，就涉及<strong>单据创建与提交策略</strong>（如自动拆合单、静态组波）、<strong>出库优先级调整策略</strong>（按发货时间、作业时长、剩余任务数动态调整）、<strong>库存分配策略</strong>（多库区优先级）、<strong>工作站作业策略</strong>（绑箱、槽位匹配与释放）等数十个可配置项。</p>
</li>
<li>
<p><strong>规则的逻辑条件复杂</strong>：一个策略的生效往往是多重条件组合判断的结果。例如，“出库单初始优先级”策略，需要根据“出库单类型”来决定其初始的“优先级等级”和“优先级值”。这种 <code>if...else if...else</code>的链式判断，在传统编码中会形成难以维护的“代码沼泽”。<br>
<img src="https://github.com/PansonPanson/supply-chain/blob/main/%E4%BE%9B%E5%BA%94%E9%93%BE%E5%AD%90%E7%B3%BB%E7%BB%9F/%E6%99%BA%E8%83%BD%E4%BB%93%E5%82%A8%E7%B3%BB%E7%BB%9F/%E9%87%8D%E6%9E%84%E7%AF%87/assets/WES%20%E9%87%8D%E6%9E%84%E7%B3%BB%E5%88%97%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E5%A4%8D%E6%9D%82%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E8%A7%84%E5%88%99/file-20251206191127744.png?raw=true" alt="" loading="lazy"></p>
</li>
<li>
<p><strong>规则的动态性要求高</strong>：业务策略并非一成不变。新的客户需求、运营优化尝试都要求规则能够快速调整、热生效，而不需要重启服务或发布新版本。例如，快速调整“缺货提交方式”为“有货先作业”以应对临时的爆仓压力，必须是分钟级可配置的能力。</p>
</li>
</ul>
<p>面对这种“多、变、杂”的业务规则，如果继续沿用硬编码的方式，会直接导致：</p>
<ol>
<li>
<p><strong>核心业务逻辑与规则逻辑耦合</strong>：业务代码中充斥着规则判断，可读性急剧下降。</p>
</li>
<li>
<p><strong>维护成本高昂</strong>：任何微小的规则变更都需要开发人员介入修改代码、测试、上线，无法快速响应业务。</p>
</li>
<li>
<p><strong>知识壁垒</strong>：业务规则散落在数十万行代码中，新人难以理解，业务专家（如资深的仓储规划师）也无法直接参与规则的制定与调整。</p>
</li>
</ol>
<h3 id="2-技术选型思考为什么是-drools">2、技术选型思考：为什么是 Drools？</h3>
<p>基于上述痛点，我们明确了引入规则引擎的核心目标：<strong>将易变的业务规则从稳定的程序逻辑中解耦出来，实现业务规则的统一管理、可视化和动态配置。</strong></p>
<p>在选型时，我们考察了多种方案：</p>
<ol>
<li>
<p><strong>脚本引擎（如 Groovy, Lua）</strong>：灵活性高，但对于复杂的条件网络和规则推理支持较弱，需要自行实现优先级、冲突解决等机制，开发量和复杂度不可控。</p>
</li>
<li>
<p><strong>自定义规则解析器（如 XML/JSON 配置 + 自研引擎）</strong>：初期看似简单，但随着规则复杂度的提升，自定义的语法和引擎在性能、功能完备性上很难与成熟产品媲美，容易重复造轮子且后期难以维护。</p>
</li>
<li>
<p><strong>商用规则引擎</strong>：功能强大，但存在商业许可成本，与我们的开源技术栈整合和自主可控的要求不符。<br>
<img src="https://github.com/PansonPanson/supply-chain/blob/main/%E4%BE%9B%E5%BA%94%E9%93%BE%E5%AD%90%E7%B3%BB%E7%BB%9F/%E6%99%BA%E8%83%BD%E4%BB%93%E5%82%A8%E7%B3%BB%E7%BB%9F/%E9%87%8D%E6%9E%84%E7%AF%87/assets/WES%20%E9%87%8D%E6%9E%84%E7%B3%BB%E5%88%97%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E5%A4%8D%E6%9D%82%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E8%A7%84%E5%88%99/file-20251206191147128.png?raw=true" alt="" loading="lazy"></p>
</li>
</ol>
<p>最终，我们选择了 <strong>Drools</strong>，主要基于以下几点考量：</p>
<ul>
<li>
<p><strong>成熟性与社区生态</strong>：Drools 是 JBoss 旗下的开源项目，经过多年发展，社区活跃，文档丰富，是一个非常成熟、稳定的企业级规则引擎解决方案。</p>
</li>
<li>
<p><strong>强大的规则表达能力</strong>：其核心的 DRL（Drools Rule Language）语言专为规则设计，支持声明式的规则编写（<code>When-Then</code>），天然契合我们的业务场景。它内置的 RETE 算法对于处理大量规则和数据有很高的效率。</p>
</li>
<li>
<p><strong>与 Java 技术栈的无缝集成</strong>：WES 核心系统基于 Java 技术栈，Drools 可以非常方便地集成到 Spring 等主流框架中，降低了引入新技术栈的架构风险和学习成本。</p>
</li>
<li>
<p><strong>“可进化”的架构潜力</strong>：Drools 不仅是一个规则执行引擎，其提供的 **KIE（Knowledge Is Everything）**​ 工作台概念，为我们未来构建图形化、Web 化的策略规则管理平台（正如策略中心）奠定了坚实的技术基础。</p>
</li>
</ul>
<h3 id="3-架构与落地将业务规则抽象为-drools-规则">3、架构与落地：将业务规则抽象为 Drools 规则</h3>
<p>选型只是第一步，如何将复杂的业务规则优雅地映射到 Drools 的规则模型中，是体现架构能力的关键。</p>
<p><strong>1. 核心模型抽象</strong></p>
<p>我们首先对策略中心的配置进行了领域模型抽象。每一个策略项（如“出库单初始优先级”）被抽象为一个 <code>Policy</code>聚合根，其下包含多条有序的 <code>Rule</code>。每条 <code>Rule</code>由 <code>Condition</code>（匹配条件）和 <code>Action</code>（结论数据）组成。这个领域模型与 Drools 的 <code>Rule</code>, <code>LHS</code>(Left Hand Side), <code>RHS</code>(Right Hand Side) 概念可以完美对应。</p>
<p><strong>2. 动态规则加载</strong></p>
<p>我们并没有让业务人员直接编写 DRL 文件，而是基于策略中心的数据库配置，在运行时动态生成 DRL 规则内容。系统启动或策略变更时，会从数据库拉取最新配置，通过模板技术将其转换为标准的 DRL 语法，然后加载到 Drools 的 <code>KieSession</code>中。这样，策略中心UI上的每一次“保存”操作，就相当于完成了一次业务规则的“发布”。</p>
<p><strong>3. 规则执行与集成</strong></p>
<p>在业务逻辑的关键节点（如“创建出库单”、“分配库存”前），我们将业务对象（如 <code>Order</code>对象）作为 <code>Fact</code>插入到 <code>KieSession</code>中，触发规则引擎执行。引擎会根据定义的规则顺序和优先级，对 <code>Fact</code>进行匹配和推理，并执行相应的 <code>Action</code>，修改对象的状态。执行完毕后，我们只需取出被规则修改过的对象，继续后续的业务流程即可。整个过程对核心业务代码几乎是透明的。</p>
<h2 id="4-重构收益">4、重构收益</h2>
<p>引入 Drools 规则引擎后，我们获得了显著的收益：</p>
<ul>
<li>
<p><strong>架构清晰，职责分离</strong>：业务代码不再关心“如何判断”，只关注“做什么”，代码变得简洁、可读、易测试。</p>
</li>
<li>
<p><strong>响应速度飞跃</strong>：常用规则基本百分百覆盖，现在可以由实施顾问或运维人员通过策略中心界面直接完成，无需开发介入，开新仓的时候，直接可以按需配置。</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[近期关于大模型应用落地的一些思考]]></title>
        <id>https://panson.top/post/jin-qi-guan-yu-da-mo-xing-ying-yong-luo-di-de-yi-xie-si-kao/</id>
        <link href="https://panson.top/post/jin-qi-guan-yu-da-mo-xing-ying-yong-luo-di-de-yi-xie-si-kao/">
        </link>
        <updated>2025-12-04T03:38:30.000Z</updated>
        <summary type="html"><![CDATA[<p><em>图床用了 GitHub，文内所有图片都需要科学上网才可以流畅阅读。</em></p>
<p>整理一下思绪和最近的事情，最近因为太忙了，所以直接住在公司附近的酒店里。因为不再长距离通勤而节约下来的夜晚时间，显得弥足珍贵。</p>
<p>11 月末到 12 月初是海外黑五的时间段，估计海外仓问题可能比较紧急，加上今晚 oncall，躺着也睡不着，干脆起来写点东西。白天喝了红牛，写点东西助眠。</p>
]]></summary>
        <content type="html"><![CDATA[<p><em>图床用了 GitHub，文内所有图片都需要科学上网才可以流畅阅读。</em></p>
<p>整理一下思绪和最近的事情，最近因为太忙了，所以直接住在公司附近的酒店里。因为不再长距离通勤而节约下来的夜晚时间，显得弥足珍贵。</p>
<p>11 月末到 12 月初是海外黑五的时间段，估计海外仓问题可能比较紧急，加上今晚 oncall，躺着也睡不着，干脆起来写点东西。白天喝了红牛，写点东西助眠。</p>
<!-- more -->
<figure data-type="image" tabindex="1"><img src="https://images.unsplash.com/photo-1762222630690-20a58212af83?q=80&amp;w=2670&amp;auto=format&amp;fit=crop&amp;ixlib=rb-4.1.0&amp;ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D" alt="" loading="lazy"></figure>
<hr>
<p>冬天的夜晚很安静，能听到遥远的犬吠声，公司今年有了自己的园区，所以来了一次大搬家，但位置很偏远。在魔都能有这种静谧的时刻，说明真的到郊区了。</p>
<p>写点最近关于 AI 落地的思考吧。</p>
<h4 id="一-背景与契机"><strong>一、背景与契机</strong></h4>
<p>我司智能仓项目目前已有数百家规模，每个项目的需求、工单都会流经内部的ONES系统。这个过程中，系统里沉淀了许多来自不同项目的线上问题SOP（标准作业程序）以及丰富的项目细节。</p>
<p>另外我司的工作文档一部分在语雀上，一部分在 confluence 上，文档数量非常多，但很散乱，目前尚未被充分挖掘和利用，我在思考，是否可以基于这些数据构建一个RAG（检索增强生成）系统，让其成为一个智能的业务助手。</p>
<h4 id="二-数据来源规划"><strong>二、数据来源规划</strong></h4>
<p>要实现这个想法，我计划整合以下几类数据：</p>
<ul>
<li>
<p><strong>工单数据</strong>：与IT团队合作，将历史工单数据导出，包括项目信息、工单背景、处理过程和相关的SOP。</p>
</li>
<li>
<p><strong>项目文档</strong>：涵盖项目需求文档、缺陷记录、项目背景说明等。</p>
</li>
<li>
<p><strong>架构与知识文档</strong>：包括应用架构图、实操手册、数据模型设计，以及沉淀在语雀和Confluence中的历史文档。<br>
<img src="https://github.com/PansonPanson/supply-chain/blob/main/%E4%BE%9B%E5%BA%94%E9%93%BE%E5%AD%90%E7%B3%BB%E7%BB%9F/%E6%99%BA%E8%83%BD%E4%BB%93%E5%82%A8%E7%B3%BB%E7%BB%9F/%E6%8A%80%E6%9C%AF%E7%AF%87/assets/%E8%BF%91%E6%9C%9F%E5%85%B3%E4%BA%8E%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BA%94%E7%94%A8%E8%90%BD%E5%9C%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/file-20251204211019886.png?raw=true" alt="" loading="lazy"></p>
</li>
</ul>
<h4 id="三-目标用户"><strong>三、目标用户</strong></h4>
<p>这个系统旨在服务所有与项目相关的同事，主要包括：</p>
<ol>
<li>
<p><strong>一线PE（项目实施/运维工程师）</strong></p>
</li>
<li>
<p><strong>二线技术支持</strong></p>
</li>
<li>
<p><strong>三线测试人员</strong></p>
</li>
<li>
<p><strong>四线研发人员</strong></p>
</li>
<li>
<p><strong>相关的产品、研发、测试同学</strong></p>
</li>
</ol>
<figure data-type="image" tabindex="2"><img src="https://github.com/PansonPanson/supply-chain/blob/main/%E4%BE%9B%E5%BA%94%E9%93%BE%E5%AD%90%E7%B3%BB%E7%BB%9F/%E6%99%BA%E8%83%BD%E4%BB%93%E5%82%A8%E7%B3%BB%E7%BB%9F/%E6%8A%80%E6%9C%AF%E7%AF%87/assets/%E8%BF%91%E6%9C%9F%E5%85%B3%E4%BA%8E%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BA%94%E7%94%A8%E8%90%BD%E5%9C%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/file-20251204211108413.png?raw=true" alt="" loading="lazy"></figure>
<h4 id="四-核心功能设想"><strong>四、核心功能设想</strong></h4>
<p>我希望它能实现以下具体功能：</p>
<ol>
<li>
<p><strong>项目背景快速查询</strong>：用户输入项目号，即可快速了解项目背景和核心需求列表。</p>
</li>
<li>
<p><strong>对话式业务学习</strong>：用户可以以对话形式，学习我司的业务架构、技术架构和应用架构。</p>
</li>
<li>
<p><strong>智能排查辅助</strong>：当出现问题时，系统能提示核心链路表的使用方法，并建议结合哪些业务监控指标进行下一步排查。</p>
</li>
<li>
<p><strong>SOP智能提示</strong>：能够主动推送常见问题的标准处理流程（SOP）。</p>
</li>
</ol>
<figure data-type="image" tabindex="3"><img src="https://github.com/PansonPanson/supply-chain/blob/main/%E4%BE%9B%E5%BA%94%E9%93%BE%E5%AD%90%E7%B3%BB%E7%BB%9F/%E6%99%BA%E8%83%BD%E4%BB%93%E5%82%A8%E7%B3%BB%E7%BB%9F/%E6%8A%80%E6%9C%AF%E7%AF%87/assets/%E8%BF%91%E6%9C%9F%E5%85%B3%E4%BA%8E%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BA%94%E7%94%A8%E8%90%BD%E5%9C%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/file-20251204211139320.png?raw=true" alt="" loading="lazy"></figure>
<h4 id="五-后续计划与个人思考"><strong>五、后续计划与个人思考</strong></h4>
<p>如果明年我还每走，就做一下看看。</p>
<p><strong>一点观察</strong>：这项工作原本或许是AI LAB的职责，但由于我们组的业务壁垒相对较高，外部团队很难在短时间内深入理解我们的业务上下文，因此应用层的很多工具还是需要我们业务团队自己来动手构建。</p>
<p>目前我对大模型应用的了解尚属入门阶段，但我相信“在实战中学习”是最好的方式。边做边学，逐步深入。我预感这个工具一旦完成，将能解决很多实际痛点，比如：</p>
<ul>
<li>
<p><strong>新人培训效率</strong>：加速新成员对复杂业务系统的理解。</p>
</li>
<li>
<p><strong>跨团队业务理解</strong>：帮助二、三、四线人员快速掌握业务全貌。</p>
</li>
<li>
<p><strong>工单处理效率</strong>：快速提供解决方案参考，缩短问题排查时间。</p>
</li>
</ul>
<p>我也在网上看了一些RAG的教程，但发现许多内容偏向理论讲解，与实际业务场景的结合案例相对较少，还是得自己摸索一下，找时间去咨询一下大厂的一线开发朋友，闭门造车有点难~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[考虑自己写一个照片处理的分布式 AI Agent 项目]]></title>
        <id>https://panson.top/post/kao-lu-zi-ji-xie-yi-ge-zhao-pian-chu-li-de-fen-bu-shi-ai-agent-xiang-mu/</id>
        <link href="https://panson.top/post/kao-lu-zi-ji-xie-yi-ge-zhao-pian-chu-li-de-fen-bu-shi-ai-agent-xiang-mu/">
        </link>
        <updated>2025-11-17T06:52:25.000Z</updated>
        <summary type="html"><![CDATA[<p>2019年，我入手了一台MacBook Pro，那是英特尔芯片的末代机型，配置是16GB内存和1TB硬盘。 当时我以为，这台电脑即便用到寿终正寝，磁盘空间恐怕也消耗不完。</p>
<p>然而未来总是难以预料（充满惊喜）。去年生日，爱人送了我一台尼康相机，我的人生仿佛又增加了一个新的锚点——摄影。</p>
]]></summary>
        <content type="html"><![CDATA[<p>2019年，我入手了一台MacBook Pro，那是英特尔芯片的末代机型，配置是16GB内存和1TB硬盘。 当时我以为，这台电脑即便用到寿终正寝，磁盘空间恐怕也消耗不完。</p>
<p>然而未来总是难以预料（充满惊喜）。去年生日，爱人送了我一台尼康相机，我的人生仿佛又增加了一个新的锚点——摄影。</p>
<!-- more -->
<p>快门的每一次开合，都意味着磁盘空间减少约30MB。摄影一周年之际，Mac的硬盘空间开始告急，我不得不将一部分照片迁移到另一台电脑上。这也促使我考虑开始整理旧照片：重复度高的，挑选一两张优质的保留，其余则可以冷归档。</p>
<p>好的照片需要“装裱”。我在GitHub上找到了一个名为 https://github.com/leslievan/semi-utils 的Python项目，它支持照片批量添加水印、调整像素比、处理图像色彩和质量。 于是我便思考，能否采用AI Agent的方式来实现照片的自动化处理。 这主要基于两点考虑：其一，照片的二次修改和包装逻辑本质上就是任务，我有多年的分布式任务调度系统开发经验；其二，大模型相关技术如MCP、RAG、Agent正是当下的热点，我也希望借此机会实践学习。 将分布式任务调度系统与Agent结合，可谓一举多得。</p>
<p>初步方案（思考中）</p>
<p>若将照片的二次处理抽象为一个任务，系统大致可划分为以下几个部分：<br>
•   任务数据上传与前置处理系统</p>
<p>•   任务分发中心</p>
<p>•   任务二次处理系统：与Agent交互，生成处理后的照片</p>
<p>•   照片下载系统</p>
<p>整体的数据流初步设想如下：<br>
用户上传照片<br>
→ 进行前置处理（如文件格式校验、持久化存储，并抽象为任务）<br>
→ 任务分发中心（初期架构可简化，专注于分发）<br>
→ 任务二次处理系统（与Agent交互，完成照片处理）<br>
→ 用户下载最终照片</p>
<p>当然，细节还有很多。例如前置的照片上传入口和UI交互、任务分发中心的实现（单机扫表、ZK选主、XXL-JOB，或是Redis/MQ队列等都可以考虑）。</p>
<p>总之，先聚焦核心链路，实现数据闭环，再考虑后续演进。</p>
<p>改天研究一下阿里通义千问和豆包的文档，看看如何对接。虽然想尽快开始，但还得准备面试，时间有些紧张。或许这个项目要等跳槽后再正式动工了，不过思路既已明确，落地便只是时间问题。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一次 JVM “神优化” 导致的日志丢失问题]]></title>
        <id>https://panson.top/post/yi-ci-jvm-shen-you-hua-dao-zhi-de-ri-zhi-diu-shi-wen-ti/</id>
        <link href="https://panson.top/post/yi-ci-jvm-shen-you-hua-dao-zhi-de-ri-zhi-diu-shi-wen-ti/">
        </link>
        <updated>2025-10-30T05:56:13.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="一-问题发生">一、问题发生</h2>
<p>今天同事私聊我，问了我一个问题，他说在一个美国的海外仓项目中发现一个奇怪的报错日志：只有error 日志信息和一个 NPE 日常，但是没有打印出具体的堆栈。</p>
<p>他问我有没有遇到过。</p>
<p>我心里第一个想法：是不是打印日志的地方写得不规范，只把 Exception 的 message 打印了，类似这样：</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="一-问题发生">一、问题发生</h2>
<p>今天同事私聊我，问了我一个问题，他说在一个美国的海外仓项目中发现一个奇怪的报错日志：只有error 日志信息和一个 NPE 日常，但是没有打印出具体的堆栈。</p>
<p>他问我有没有遇到过。</p>
<p>我心里第一个想法：是不是打印日志的地方写得不规范，只把 Exception 的 message 打印了，类似这样：</p>
<!-- more -->
<pre><code class="language-java">log.error(&quot;…… &quot;, exception.getMessage());
</code></pre>
<p>去看了一下代码，发现代码中其实是完整打印的：</p>
<pre><code class="language-java">try {
    // 执行调度逻辑：方法内部调用算法服务，分配库存
} catch (Exception exception) {
     log.error(&quot;……&quot;,  exception);
} finally {
     //
}
</code></pre>
<h2 id="二-求助-ai">二、求助 AI</h2>
<p>面对这个反常的现象，我一开始也向我的好帮手——AI 提问了。</p>
<p>我尝试了各种姿势，并给了一些上下文，去问 AI，得到了一些排查方向：<br>
​1. 确认日志框架​<br>
确认项目使用的是 Logback, Log4j2 还是其他日志框架。<br>
​2. 检查日志级别​<br>
确保记录异常时使用的级别（如 ERROR）在配置中是启用的。<br>
​3. 检查日志配置​<br>
核对配置文件（如 logback.xml, log4j2.xml），看输出目的地（控制台、文件）是否正确。<br>
​4. 验证日志实现​<br>
在 catch块中增加简单输出（如 System.out.println），确认代码执行路径。<br>
……</p>
<p>但似乎没找到我想要的答案。</p>
<h2 id="三-拨云见日十年前的老帖子">三、拨云见日：十年前的“老帖子”</h2>
<p>我决定重新梳理所有上下文，包括业务的调用频率、JVM 的运行环境等等。这个定时器是高频运行的，且每次都会在<strong>同一个地方</strong>报 <strong>NPE</strong>。</p>
<p>我抱着试一试的心态，在 Google/知乎上搜索一些“Java 异常 堆栈 丢失 性能优化”之类的关键词。结果，R 大在 <strong>十年前</strong> 的回答，瞬间击碎了所有的迷雾！</p>
<blockquote>
<p><strong>帖子地址：</strong> <a href="https://www.zhihu.com/question/21405047/answer/45055055">重载 Throwable.fillInStackTrace() 方法以提高Java性能这样的做法对吗？ - RednaxelaFX的回答 - 知乎</a></p>
</blockquote>
<p>R 大的回答里提到了一个 <strong>HotSpot VM</strong> 的“神优化”——<strong>fast throw</strong>！</p>
<blockquote>
<p>HotSpot VM 有个许多人觉得“匪夷所思”的优化，叫做 <strong>fast throw</strong>：有些特定的隐式异常类型（<code>NullPointerException</code>、<code>ArithmeticException</code>（ <code>/ 0</code>）之类）如果在代码里某个特定位置被抛出过多次的话，HotSpot Server Compiler（C2）会透明地决定用 <strong>fast throw</strong> 来优化这个抛出异常的地方——直接抛出一个事先分配好的、类型匹配的异常对象。这个对象的 <code>message</code> 和 <strong>stack trace 都被清空</strong>。</p>
</blockquote>
<p><strong>划重点：</strong> <strong><code>message</code> 和 <code>stack trace 都被清空</code>！</strong></p>
<p><strong>简直是醍醐灌顶！</strong></p>
<p>这种优化的目的是：<strong>抛出这个异常的速度是非常快，不但不用额外分配内存，而且也不用爬栈；</strong> 但缺点就是：<strong>可能正好是需要知道哪里出问题的时候看不到 stack trace 了。</strong></p>
<p>这不就是我的问题吗？！！</p>
<p>顺着这个思路，看了一下这个定时器最早的一次报错，果然是带完整的堆栈信息的。<br>
结合我们的代码，至此可以破案了：获取库位信息并遍历的代码，它被 <strong>高频</strong> 调用，而且由于数据问题，它一直在报 <code>NPE</code>。</p>
<p>JVM 的 C2 编译器一看：“呦，指这行代码天天抛一样的异常，怪累的，我帮他优化一下吧！” 于是，它启动了 <strong>fast throw</strong> 机制，直接抛出预先分配好的、没有堆栈的 <code>NPE</code> 对象，大大提升了抛出异常的速度，但同时也“贴心”地清空了我的日志堆栈！</p>
<h2 id="四-反思">四、反思</h2>
<p>这事儿说到底，是因为我们代码里的 <strong>NPE Bug</strong> 成了 JVM 优化的“燃料”。</p>
<p>当然，知道原因后，我们首先要做的肯定是修复那个导致 NPE 的 Bug。</p>
<p>但从 JVM 层面，如果你确实需要知道高频异常的堆栈，你可以通过一个 VM 参数来<strong>禁用</strong>这个优化：</p>
<pre><code class="language-bash">-XX:-OmitStackTraceInFastThrow
</code></pre>
<p>不过，这个参数的意义是“以性能为代价，换取更完整的堆栈信息”，所以，<strong>更正确的姿势，永远是写出健壮的代码，避免高频抛出隐式异常！</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[WES 重构系列（十一）：出库链路中的分布式事务 Saga 实践]]></title>
        <id>https://panson.top/post/wes-chong-gou-xi-lie-shi-yi-chu-ku-lian-lu-zhong-de-fen-bu-shi-shi-wu-saga-shi-jian/</id>
        <link href="https://panson.top/post/wes-chong-gou-xi-lie-shi-yi-chu-ku-lian-lu-zhong-de-fen-bu-shi-shi-wu-saga-shi-jian/">
        </link>
        <updated>2025-04-16T04:52:21.000Z</updated>
        <summary type="html"><![CDATA[<p>我在现司的很长一段时间里一直被现场问题工单 oncall 弄得痛不欲生，大概有半年多，我司很多第三方仓，尤其是海外仓，跨时区工作，经常半夜打我电话，一起床又是一个通宵。坦诚来说，工作这么多年，在我司的前半段时间工作，是我职业生涯中最痛苦的一段时间，捂头哈哈~</p>
]]></summary>
        <content type="html"><![CDATA[<p>我在现司的很长一段时间里一直被现场问题工单 oncall 弄得痛不欲生，大概有半年多，我司很多第三方仓，尤其是海外仓，跨时区工作，经常半夜打我电话，一起床又是一个通宵。坦诚来说，工作这么多年，在我司的前半段时间工作，是我职业生涯中最痛苦的一段时间，捂头哈哈~</p>
<!-- more -->
<p>这段经历让我切身体会到：<strong>当核心履约链路缺乏系统性设计时，稳定性问题最终一定会以“人工成本”的形式被偿还。</strong></p>
<p>后来，在一位在公司深耕十年的前辈建议和引荐下，我转入产品线团队，参与 WES 系统的重构工作，也正是在这一过程中，我开始系统性地审视出库链路，并逐步引入 Saga 思想来解决长期存在的履约一致性问题。</p>
<p>收获良多，我很感谢他。</p>
<figure data-type="image" tabindex="1"><img src="https://images.unsplash.com/photo-1755109604669-2719abfbe5b6?q=80&amp;w=2777&amp;auto=format&amp;fit=crop&amp;ixlib=rb-4.1.0&amp;ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D" alt="" loading="lazy"></figure>
<p>在仓储系统中，出库履约是一条<strong>跨系统、跨资源、长生命周期</strong>的业务链路，涉及到状态机、库存模型、调度模型、规则配置等等。本文结合我过往在 WES（Warehouse Execution System）中的工程实践，分享出库链路中落地 Saga 的思考、演进过程与经验总结。</p>
<hr>
<h1 id="一-仓储业务名词解释">一、仓储业务名词解释</h1>
<p>为了便于不同业务领域背景的朋友能理解本文的一些内容，加了一些名词说明。</p>
<figure data-type="image" tabindex="2"><img src="https://github.com/PansonPanson/supply-chain/blob/main/%E4%BE%9B%E5%BA%94%E9%93%BE%E5%AD%90%E7%B3%BB%E7%BB%9F/%E6%99%BA%E8%83%BD%E4%BB%93%E5%82%A8%E7%B3%BB%E7%BB%9F/%E9%87%8D%E6%9E%84%E7%AF%87/assets/WES%20%E9%87%8D%E6%9E%84%E7%B3%BB%E5%88%97%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E5%87%BA%E5%BA%93%E9%93%BE%E8%B7%AF%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%20Saga%20%E5%AE%9E%E8%B7%B5/file-20251213233756392.png?raw=true" alt="" loading="lazy"></figure>
<h3 id="1-出库单">1. 出库单</h3>
<p>出库单本质上是上游下发的单据，比如你在淘宝上买了 2 个牙刷，3 件毛巾。那上游（可能是 OMS、WMS）会下发一个出库单到 WES 来，告知 WES 我现在要出货配送 2 个牙刷、3 件毛巾。出库单就是用来表达要出库的商品信息。</p>
<p>在数据模型上，出库单分为主体和明细。</p>
<h2 id="2-出库作业单">2. 出库作业单</h2>
<p>出库作业单某种层面上是根据出库单做的一层解耦单据，将具体的执行层与上游下发的单据层隔离开。<br>
另一个维度来理解的话，是按库区维度对出库单做了一次拆单。<br>
出库作业单单也有主体和明细。比如说上文的出库单，可能会分裂成两个出库单，A 库区出库 2 件牙刷，B 库区出库 3 件毛巾。</p>
<h2 id="3-出库任务">3. 出库任务</h2>
<p>出库任务业务含义上表示要从某个存储库位（货架库位、料箱、料格）中出库某个包装批次的商品。</p>
<p>WES 会对这个出库任务做一层转换，加上搬运调度层的含义，比如要把这个商品放到哪个工作站的那个槽位上去拣选，搬运的目的地是哪里。</p>
<h2 id="4二级库存">4.二级库存</h2>
<p>库区层面的库存，智能仓分为多个库区，二级库存是库区维度商品批次库存。</p>
<h2 id="5三级库存">5.三级库存</h2>
<p>库位维度的库存，实际的存储库存，比二级库存会更细粒度一些。</p>
<h2 id="二-背景为什么出库履约是一个长事务问题">二、背景：为什么出库履约是一个“长事务”问题</h2>
<p>在 WES 中，一次出库并非一个同步完成的动作，而是由多个阶段逐步推进：</p>
<ul>
<li>
<p>上游系统下发出库单</p>
</li>
<li>
<p>根据规则拆分出库单生成出库作业单，预占二级库存</p>
</li>
<li>
<p>与算法服务交互，分配工作站槽位</p>
</li>
<li>
<p>与算法服务交互，分配三级库存，生成并下发搬运任务</p>
</li>
<li></li>
<li>
<p>将调度任务下发至下游搬运集群</p>
</li>
<li>
<p>小车到站推送拣选实操</p>
</li>
<li>
<p>实操反馈，扣减二三级库存，完结作业单、任务，小车离站</p>
</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://github.com/PansonPanson/supply-chain/blob/main/%E4%BE%9B%E5%BA%94%E9%93%BE%E5%AD%90%E7%B3%BB%E7%BB%9F/%E6%99%BA%E8%83%BD%E4%BB%93%E5%82%A8%E7%B3%BB%E7%BB%9F/%E9%87%8D%E6%9E%84%E7%AF%87/assets/WES%20%E9%87%8D%E6%9E%84%E7%B3%BB%E5%88%97%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E5%87%BA%E5%BA%93%E9%93%BE%E8%B7%AF%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%20Saga%20%E5%AE%9E%E8%B7%B5/file-20251213234238868.png?raw=true" alt="" loading="lazy"></figure>
<p>这一过程具备几个典型特征：</p>
<ul>
<li>
<p>涉及多个本地事务</p>
</li>
<li>
<p>业务链路长，状态中间态多</p>
</li>
<li>
<p>允许失败、需要回滚和重试</p>
</li>
<li>
<p>对可用性要求高，不追求强一致</p>
</li>
</ul>
<p>这使得传统的强一致分布式事务（如 XA / 2PC）在该场景下并不适用。</p>
<hr>
<h2 id="三-saga-原理回顾结合我个人的工程视角">三、Saga 原理回顾（结合我个人的工程视角）</h2>
<p>名词说明：Saga 从何而来</p>
<p>Saga 并不是一个首字母缩写词（并不存在官方的“全称”），而是来源于北欧语 saga，原意是长篇史诗、连续发生的一系列故事。</p>
<p>在分布式系统语境下，这个词被用来形容一类非常贴切的事务形态：</p>
<p>由一系列本地事务组成、跨越较长时间、可能失败但可以通过补偿回到业务可接受状态的事务过程。</p>
<p>这一概念最早由 Hector Garcia-Molina 等人在数据库领域提出，后来逐步演进为我们今天所说的 Saga Pattern（Saga 模式）。</p>
<p>从工程角度理解，Saga 更像是：</p>
<p>一段允许中间不一致的业务“叙事过程”</p>
<p>每一步都是**可落库、可观测、可回滚（补偿）**的本地事务</p>
<p>最终目标不是强一致，而是业务上的闭环与可控收敛</p>
<p>这一点，与仓储履约这种“长链路、强现实约束”的业务形态高度契合。</p>
<h3 id="1-什么是-saga">1. 什么是 Saga</h3>
<p>Saga 是一种用于解决<strong>分布式长事务</strong>的问题模型，其核心思想是：</p>
<ul>
<li>
<p>将一个全局事务拆分为多个<strong>可独立提交的本地事务</strong></p>
</li>
<li>
<p>每个本地事务都对应一个<strong>补偿操作</strong></p>
</li>
<li>
<p>通过正向执行与必要时的补偿执行，最终达成一致状态</p>
</li>
</ul>
<p>Saga 的目标不是“永不失败”，而是：</p>
<blockquote>
<p><strong>在允许中间不一致的前提下，确保系统最终回到一个业务可接受、可解释、可恢复的状态</strong>。</p>
</blockquote>
<hr>
<h3 id="2-编排型-saga-vs-协同型-saga">2. 编排型 Saga vs 协同型 Saga</h3>
<p>Saga 通常分为两类：</p>
<ul>
<li>
<p><strong>协同型（Choreography）</strong>：各参与方通过事件协作推进</p>
</li>
<li>
<p><strong>编排型（Orchestration）</strong>：由一个中心节点统一编排流程<br>
<img src="https://github.com/PansonPanson/supply-chain/blob/main/%E4%BE%9B%E5%BA%94%E9%93%BE%E5%AD%90%E7%B3%BB%E7%BB%9F/%E6%99%BA%E8%83%BD%E4%BB%93%E5%82%A8%E7%B3%BB%E7%BB%9F/%E9%87%8D%E6%9E%84%E7%AF%87/assets/WES%20%E9%87%8D%E6%9E%84%E7%B3%BB%E5%88%97%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E5%87%BA%E5%BA%93%E9%93%BE%E8%B7%AF%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%20Saga%20%E5%AE%9E%E8%B7%B5/file-20251213234323066.png?raw=true" alt="" loading="lazy"></p>
</li>
</ul>
<p>在 WES 出库场景中，我们选择的是：</p>
<blockquote>
<p><strong>以出库单为业务目标的编排型 Saga</strong></p>
</blockquote>
<p>原因很简单：</p>
<ul>
<li>
<p>WES 本身就是履约编排中枢</p>
</li>
<li>
<p>下游系统（如 WCS）不具备事务补偿能力</p>
</li>
<li>
<p>需要明确、可控的流程推进与回滚逻辑</p>
</li>
</ul>
<hr>
<h2 id="四-wes-出库-saga-的业务建模">四、WES 出库 Saga 的业务建模</h2>
<h3 id="1-saga-的业务边界">1. Saga 的业务边界</h3>
<ul>
<li>
<p><strong>Saga 实例粒度</strong>：出库单</p>
</li>
<li>
<p><strong>Saga 目标</strong>：完成一次出库履约（成功或可控失败）</p>
</li>
</ul>
<p>出库单天然就是一个 Saga 的生命周期边界。</p>
<hr>
<h3 id="2-核心业务对象">2. 核心业务对象</h3>
<ul>
<li>
<p>出库单（Outbound Order）</p>
</li>
<li>
<p>出库作业单（Work ）</p>
</li>
<li>
<p>出库任务（Job）</p>
</li>
<li>
<p>二级库存（L2，逻辑库存）</p>
</li>
<li>
<p>三级库存（L3，具体到库位库存）</p>
</li>
<li>
<p>工作站 / WCS</p>
</li>
</ul>
<p>这些对象的<strong>状态变化</strong>，共同构成了 Saga 的执行轨迹。</p>
<hr>
<h2 id="五-saga-的正向履约流程">五、Saga 的正向履约流程</h2>
<figure data-type="image" tabindex="4"><img src="https://github.com/PansonPanson/supply-chain/blob/main/%E4%BE%9B%E5%BA%94%E9%93%BE%E5%AD%90%E7%B3%BB%E7%BB%9F/%E6%99%BA%E8%83%BD%E4%BB%93%E5%82%A8%E7%B3%BB%E7%BB%9F/%E9%87%8D%E6%9E%84%E7%AF%87/assets/WES%20%E9%87%8D%E6%9E%84%E7%B3%BB%E5%88%97%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E5%87%BA%E5%BA%93%E9%93%BE%E8%B7%AF%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%20Saga%20%E5%AE%9E%E8%B7%B5/file-20251213234432552.png?raw=true" alt="" loading="lazy"></figure>
<p>几个关键点：</p>
<ul>
<li>
<p>Saga 并不是同步完成，而是被<strong>定时器持续推进</strong></p>
</li>
<li>
<p>每一步都是独立本地事务</p>
</li>
<li>
<p>任意一步失败，都不会影响已提交步骤的可见性</p>
</li>
</ul>
<hr>
<h2 id="六-外部事件驱动的-saga工作站下线">六、外部事件驱动的 Saga：工作站下线</h2>
<p>在真实仓储环境中，<strong>资源变化是常态</strong>。</p>
<h3 id="1-典型场景工作站下线">1. 典型场景：工作站下线</h3>
<p>当某个工作站下线时：</p>
<ul>
<li>
<p>已生成但未执行的任务不可继续</p>
</li>
<li>
<p>已预占的三级库存需要释放</p>
</li>
<li>
<p>原有作业规划失效，需要重新规划</p>
</li>
</ul>
<hr>
<h3 id="2-我们的处理方式">2. 我们的处理方式</h3>
<p>在 Saga 视角下，从实现上看，这并不是一次“异常处理逻辑”，而是 Saga 在面对外部环境变化时的一次<strong>显式补偿与重编排</strong>，也是我们在仓储系统中最常见、也最重要的一类 Saga 触发方式。</p>
<p>具体行为：<br>
<img src="https://github.com/PansonPanson/supply-chain/blob/main/%E4%BE%9B%E5%BA%94%E9%93%BE%E5%AD%90%E7%B3%BB%E7%BB%9F/%E6%99%BA%E8%83%BD%E4%BB%93%E5%82%A8%E7%B3%BB%E7%BB%9F/%E9%87%8D%E6%9E%84%E7%AF%87/assets/WES%20%E9%87%8D%E6%9E%84%E7%B3%BB%E5%88%97%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E5%87%BA%E5%BA%93%E9%93%BE%E8%B7%AF%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%20Saga%20%E5%AE%9E%E8%B7%B5/file-20251213234525239.png?raw=true" alt="" loading="lazy"></p>
<p>Saga 在这里体现的是<strong>业务韧性</strong>。</p>
<hr>
<h2 id="七-saga-的工程落地方式">七、Saga 的工程落地方式</h2>
<figure data-type="image" tabindex="5"><img src="https://github.com/PansonPanson/supply-chain/blob/main/%E4%BE%9B%E5%BA%94%E9%93%BE%E5%AD%90%E7%B3%BB%E7%BB%9F/%E6%99%BA%E8%83%BD%E4%BB%93%E5%82%A8%E7%B3%BB%E7%BB%9F/%E9%87%8D%E6%9E%84%E7%AF%87/assets/WES%20%E9%87%8D%E6%9E%84%E7%B3%BB%E5%88%97%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E5%87%BA%E5%BA%93%E9%93%BE%E8%B7%AF%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%20Saga%20%E5%AE%9E%E8%B7%B5/file-20251213234621384.png?raw=true" alt="" loading="lazy"></figure>
<h3 id="1-状态机-定时器轻量级-saga-driver">1. 状态机 + 定时器：轻量级 Saga Driver</h3>
<p>我们没有引入专门的工作流或 Saga 框架，而是采用：</p>
<ul>
<li>
<p><strong>状态机</strong>：描述“当前处于哪一步”</p>
</li>
<li>
<p><strong>定时器</strong>：负责推进下一步执行</p>
</li>
</ul>
<p>这种方式：</p>
<ul>
<li>
<p>实现简单</p>
</li>
<li>
<p>易于调试</p>
</li>
<li>
<p>与业务模型高度贴合</p>
</li>
</ul>
<hr>
<h3 id="2-工作站维度的分布式锁">2. 工作站维度的分布式锁</h3>
<p>我们在工程上引入了：</p>
<blockquote>
<p><strong>以工作站为粒度的分布式锁</strong></p>
</blockquote>
<p>使用原则非常明确：</p>
<ul>
<li>
<p>锁只用于<strong>并发收敛</strong></p>
</li>
<li>
<p>不承担 Saga 一致性语义</p>
</li>
</ul>
<p>典型使用场景：</p>
<ul>
<li>
<p>生成任务</p>
</li>
<li>
<p>回滚任务</p>
</li>
<li>
<p>下发任务</p>
</li>
<li>
<p>处理工作站下线事件</p>
</li>
</ul>
<p>并且严格遵循：</p>
<blockquote>
<p><strong>锁内逻辑原子化：先提交事务，再释放锁</strong></p>
</blockquote>
<hr>
<h2 id="八-saga-的可观测性任务流转树监控">八、Saga 的可观测性：任务流转树监控</h2>
<p>Saga 最大的工程风险，不是失败，而是：</p>
<blockquote>
<p><strong>流程卡死却不可见</strong>。</p>
</blockquote>
<p>一旦 Saga 失去可观测性，工程团队就只能依赖人工介入和经验判断，这往往是系统稳定性持续恶化的开始。</p>
<p>为此，我构建了一套<strong>任务流转树监控系统</strong>。</p>
<h3 id="能看到什么">能看到什么？</h3>
<ul>
<li>
<p>一个出库单下：</p>
<ul>
<li>出库明细的信息</li>
<li>分裂成了多少作业单</li>
<li>每个作业单生成了多少任务</li>
</ul>
</li>
<li>
<p>每个 Work / Task：</p>
<ul>
<li>
<p>当前状态</p>
</li>
<li>
<p>状态的业务含义</p>
</li>
<li>
<p>在当前状态停留的时长</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://github.com/PansonPanson/supply-chain/blob/main/%E4%BE%9B%E5%BA%94%E9%93%BE%E5%AD%90%E7%B3%BB%E7%BB%9F/%E6%99%BA%E8%83%BD%E4%BB%93%E5%82%A8%E7%B3%BB%E7%BB%9F/%E9%87%8D%E6%9E%84%E7%AF%87/assets/WES%20%E9%87%8D%E6%9E%84%E7%B3%BB%E5%88%97%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E5%87%BA%E5%BA%93%E9%93%BE%E8%B7%AF%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%20Saga%20%E5%AE%9E%E8%B7%B5/file-20251214000534125.png?raw=true" alt="" loading="lazy"><br>
这使得 Saga 从“黑盒流程”变成了“白盒履约”。</p>
<hr>
<h2 id="九-我们踩过的坑-为什么没选-tcc">九、我们踩过的坑 &amp; 为什么没选 TCC</h2>
<h3 id="1-我们踩过的几个坑">1. 我们踩过的几个坑</h3>
<ul>
<li>
<p><strong>把异常当成少数情况</strong>：在仓储系统中，异常本身就是常态</p>
</li>
<li>
<p><strong>过早追求强一致</strong>：导致系统复杂度和耦合度急剧上升</p>
</li>
<li>
<p><strong>缺乏可观测性</strong>：问题只能靠日志和人工猜测</p>
</li>
</ul>
<hr>
<h3 id="2-为什么没选-tcc">2. 为什么没选 TCC</h3>
<p>我们认真评估过 TCC，但最终没有采用，原因包括：</p>
<ul>
<li>
<p>Try 阶段需要资源强锁定，不适合长时间履约</p>
</li>
<li>
<p>下游系统（如 WCS）不具备 Confirm / Cancel 能力</p>
</li>
<li>
<p>TCC 对接口侵入性极强，演进成本高</p>
</li>
</ul>
<p>相比之下，Saga：</p>
<ul>
<li>
<p>更符合“最终一致”的业务现实</p>
</li>
<li>
<p>对下游侵入小</p>
</li>
<li>
<p>更易与现有系统演进融合</p>
</li>
</ul>
<hr>
<h2 id="十-总结">十、总结</h2>
<p>我们并不是“为了 Saga 而 Saga”，而是在解决 WES 出库问题的过程中，逐步演进出了一套 Saga 实践方案。</p>
<ul>
<li>
<p>以出库单为业务目标</p>
</li>
<li>
<p>以状态机 + 定时器驱动</p>
</li>
<li>
<p>支持外部事件补偿</p>
</li>
<li>
<p>强调最终一致性与可观测性</p>
</li>
</ul>
<p>这套方案没有追求概念上的完美，但在真实复杂业务中，<strong>稳定、可控、可演进</strong>。</p>
<blockquote>
<p><strong>这，才是 Saga 在工程实践中的真正价值。</strong></p>
</blockquote>
<p>需要强调的是，这套 Saga 实践并不是通用银弹。</p>
<p>它适用于<strong>履约链路长、资源频繁变化、允许中间态存在</strong>的业务场景；<br>
对于强一致、短事务、高实时性要求的场景，Saga 反而可能引入不必要的复杂度。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[WES 重构系列（十）：聊聊 WES 单据任务调度]]></title>
        <id>https://panson.top/post/wes-chong-gou-xi-lie-shi-liao-liao-wes-dan-ju-ren-wu-diao-du/</id>
        <link href="https://panson.top/post/wes-chong-gou-xi-lie-shi-liao-liao-wes-dan-ju-ren-wu-diao-du/">
        </link>
        <updated>2025-04-15T12:06:01.000Z</updated>
        <summary type="html"><![CDATA[<p>我在前文《WES 重构系列（五）：出库调度正向链路效率优化》一文中聊过，出库链路的大致链路流程。<br>
但其实真实的出库调度链路远比这复杂，不仅涉及到库存模型、多样化的策略规则、配置、调度算法、热度算法，还涉及到单据任务调度以及相关的单据状态机、作业单状态机、任务状态机等等。</p>
]]></summary>
        <content type="html"><![CDATA[<p>我在前文《WES 重构系列（五）：出库调度正向链路效率优化》一文中聊过，出库链路的大致链路流程。<br>
但其实真实的出库调度链路远比这复杂，不仅涉及到库存模型、多样化的策略规则、配置、调度算法、热度算法，还涉及到单据任务调度以及相关的单据状态机、作业单状态机、任务状态机等等。</p>
<!-- more -->
<p>本文我将聊聊WES 的单据任务调度。</p>
<p>WES 这边的调度模型基本遵循三层：</p>
<ol>
<li>单据层：单据和单据明细</li>
<li>作业单层：作业单和作业单明细</li>
<li>任务层：包含命中的三级库存信息、容器、货架、库位</li>
</ol>
<p>从上到下，都是一对多的关系，以出库链路来说，一个出库单对应多个出库作业单，一个出库作业单对应多个出库任务。</p>
<h2 id="一-为什么要设计三层调度模型">一、为什么要设计三层调度模型？</h2>
<p>在一些小仓场景，仓内商品库存比较少，作业场景比较简单，其实作业单这一层是可以省略的，但我司的客户群体基本都是大仓，单仓过万平方，多库区，库存条目数过百万。如果只有调度任务这一层的话，无法精细化管理。比如出库单无法很好地表示库区维度的作业情况，哪些库区是有货的，哪些库区是无货的，哪些库区在作业了，哪些库区还没开始作业。</p>
<p>除了业务场景的考量，其实在模型含义上，直接使用上游下发的出库单来管理仓内作业流程，业务领域有些混淆了。出库单是上游的概念，出库单定义‘要什么’，而作业单定义‘怎么干’，关注的具体的执行层。</p>
<h2 id="二-单据-作业单-任务的状态流转">二、单据、作业单、任务的状态流转</h2>
<p>该部分信息有点涉敏，我简单聊聊。<br>
出库单是上游下发的单据，所以肯定有初始状态。<br>
提交出库单后，会预占二级库存并且生成出库作业单，出库作业单也有初始状态。<br>
出库作业单会经过复杂计算，并传给调度算法服务，最终 WES 会根据出库作业单与算法结果分配工作站、预占三级库存，并生成出库任务。<br>
同样的，出库任务也有初始状态。<br>
定时任务会流转，最终下发给下游的车辆调度系统，下发成功后，任务状态流转。<br>
车辆搬运中会不断上报任务调度实体，也就是小车的位置信息，到站后，调度任务状态变更。<br>
推完实操后，调度任务会变更为实操中。<br>
实操结束后，会变更为完成。</p>
<h2 id="三-调度的搬运优先级">三、调度的搬运优先级</h2>
<p>在履约链路中，会存在履约时效性的概念，在仓配场景中，简单来说就是，如何及时地把货物出库并配送到买家手中。</p>
<p>那上游下发的单据，可能就会带有履约时效性的信息，比如：</p>
<ol>
<li>单据优先级：优先级越高，调度任务的优先级也会根据权重提高优先级</li>
<li>期望发货时间：结合规则策略，动态根据期望发货时间提高优先级</li>
</ol>
<p>除了上游单据自带信息，在 WES 内部也会根据一些策略，去动态提高任务优先级，比如：</p>
<ol>
<li>按出库单持续时间：一个单子执行的时间越久，尾单部分，优先级就需要越高</li>
<li>按剩余拣选任务数：有的时候，上游希望剩余拣选任务数达到阈值后，能提高优先级。</li>
</ol>
<h1 id="四-库存分配优先级">四 库存分配优先级</h1>
<p>对于多库区精细化作业，需要具备按库区优先级来分配库存，比如存在 A、B 、C 库区，希望先把 A 库区的库存先出掉，再出 B、C 库区的库存。<br>
同样的，这个能力也是需要提供规则策略动态配置能力的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LLM 的发展史]]></title>
        <id>https://panson.top/post/llm-de-fa-zhan-shi/</id>
        <link href="https://panson.top/post/llm-de-fa-zhan-shi/">
        </link>
        <updated>2025-03-22T14:07:06.000Z</updated>
        <content type="html"><![CDATA[<p>大型语言模型(LLM)的发展史是一部从简单到复杂、从专用到通用、从规则驱动到数据驱动的技术进化史。<strong>这一演进过程经历了三个关键阶段：统计语言模型时代、神经网络语言模型时代和基于Transformer的大型语言模型时代</strong>。</p>
<p>每个阶段都带来了对自然语言处理(NLP)能力的质的飞跃。从早期的简单单词预测到如今能够进行复杂推理、多模态交互的通用人工智能，LLM的发展不仅重塑了人机交互方式，也为各行业带来了革命性变革。</p>
<h3 id="一-统计语言模型时代1950s-2010s">一、统计语言模型时代(1950s-2010s)</h3>
<p>统计语言模型是LLM的前身，其核心思想是通过概率统计方法来建模语言的分布规律。<strong>这一阶段的技术特点是基于离散变量表示单词，依赖人工设计的规则和统计方法处理语言</strong>，主要包括 N-gram模型和隐马尔可夫模型(HMM)。</p>
<p>N-gram 模型作为最基础的统计语言模型，最早可以追溯到 20 世纪 50 年代。它通过计算特定n个单词连续出现的概率来预测下一个单词。例如，二元语法模型(Bigram Model)计算的是当前单词和下一个单词的共现概率，三元语法模型(Trigram Model)则考虑当前单词和前两个单词的组合。这种模型结构简单、时间复杂度低，但存在明显的局限性：维度灾难、泛化能力差，以及无法处理一词多义问题  。</p>
<p>随着计算能力的提高和大规模文本语料库的增加，统计方法在 20 世纪 80-90 年代逐渐占据主导地位，特别是在机器翻译领域 。然而，由于统计语言模型学习能力有限，需要学习的词组太多，如果训练集中缺少某些词组，模型的输出概率就会变成0，导致零概率问题。</p>
<p>尽管研究者们通过平滑技术解决这一问题，但依然无法从根本上克服统计语言模型的局限性  。</p>
<p><strong>这一阶段的技术突破包括：</strong></p>
<ul>
<li>1950年：图灵测试提出，成为衡量机器智能的重要标准</li>
<li>1980-1990年代：统计机器翻译(SMT)成为主流，基于 n-gram 模型的系统如 IBM 的 MOSES 开始应用</li>
<li>2001年：Google推出PageRank算法，间接推动了语言模型的语义理解能力</li>
<li>2003年：约书亚·本吉奥提出第一个前馈神经网络语言模型(FFNNLM)，开始尝试将神经网络与语言模型结合</li>
</ul>
<h3 id="二-神经网络语言模型时代2010s">二、神经网络语言模型时代(2010s)</h3>
<p>2010年代，随着深度学习的兴起，基于神经网络的语言模型逐渐取代了统计语言模型。<strong>这一阶段的核心突破是词向量表示和循环神经网络(RNN)的引入，使语言模型能够更好地捕捉语义信息</strong>  。</p>
<p>2013年，Word2Vec和GloVe等词向量表示模型的提出实现了文本语义的分布式向量表示，解决了统计语言模型的离散变量问题。这些模型将单词映射为连续的向量空间，使得计算机能够理解单词之间的语义关系  。然而，这些静态词向量表示模型对单词的词向量表示无法随着上下文语境改变而改变，例如单词&quot;apple&quot;在苹果水果和苹果公司的语境下具有不同的含义，但静态词向量无法区分  。</p>
<p>2014年，Seq2Seq(sequence to sequence)模型被提出，这是基于RNN的模型，首次应用于机器翻译领域  。Seq2Seq模型采用编码器-解码器架构，编码器将源句子编码为特征表示，解码器根据该特征表示生成目标句子。这一模型能够实现完全端到端训练，为生成任务提供了新思路  。然而，Seq2Seq模型主要基于RNN，存在长距离依赖问题，即当输入序列比较长时，模型容易失去对位置靠前字词的记忆。</p>
<p><strong>为解决这一问题，2015年注意力机制(attention)被引入</strong>，用以改进Seq2Seq模型。注意力机制允许模型在处理序列时关注不同的位置，通过权重系数计算出哪些单词之间的关联性更大，提高了模型的可解释性  。这一创新为后续的Transformer架构奠定了基础。</p>
<p>这一阶段的主要技术突破包括：</p>
<ul>
<li>2013年：Word2Vec和GloVe词向量模型发布，开创分布式语义表示</li>
<li>2014年：Seq2Seq模型提出，采用RNN实现端到端序列建模</li>
<li>2015年：注意力机制引入，改善RNN的长距离依赖问题</li>
<li>2016年：LSTM(长短期记忆网络)在机器翻译中的应用，提升模型记忆能力</li>
<li>2017年：Transformer架构提出，彻底解决RNN的长距离依赖问题</li>
</ul>
<h3 id="三-基于transformer的大型语言模型时代2017年至今">三、基于Transformer的大型语言模型时代(2017年至今)</h3>
<p>2017年，Vaswani等人在论文《Attention Is All You Need》中提出Transformer架构，<strong>这一架构完全摒弃了传统的循环和卷积网络，仅依靠自注意力机制来处理序列数据</strong>  。</p>
<p>Transformer的出现是LLM发展的里程碑，它通过并行计算和位置编码，能够高效捕捉长距离的依赖关系，显著提升了模型性能。</p>
<h4 id="1-初期探索阶段2017-2019">1. 初期探索阶段(2017-2019)</h4>
<p>Transformer架构刚提出时，主要用于机器翻译等特定任务  。2018年，Google的高级AI研究员雅各布·德夫林等人在论文《BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding》中提出BERT模型，<strong>首次将Transformer应用于双向语言建模，使模型能够同时考虑单词的前后上下文</strong>  。BERT通过掩码语言模型(MLM)和下一句预测(NSP)两个任务进行预训练，显著提升了模型在自然语言理解任务上的表现  。</p>
<p>同年，OpenAI发布了GPT-1模型，基于Transformer的解码器架构，提出&quot;预训练+微调&quot;范式  。GPT-1有1.1亿个参数，通过在大量文本数据上进行预训练，然后针对特定任务进行微调，实现了在多种NLP任务上的出色表现  。</p>
<p>2019年，Google推出了T5模型，<strong>首次将所有NLP任务统一为文本到文本(text-to-text)格式</strong>，使模型能够处理更广泛的任务  。T5采用跨度掩码策略，随机遮蔽输入文本中的连续跨度，然后让模型预测被遮蔽的内容，这一方法进一步提升了模型的生成能力  。</p>
<h4 id="2-参数量爆发阶段2020-2022">2. 参数量爆发阶段(2020-2022)</h4>
<p>2020年，OpenAI发布了GPT-3模型，<strong>拥有1750亿个参数，验证了&quot;大模型+大数据&quot;的缩放定律(Scaling Law)</strong>  。GPT-3通过大规模预训练，实现了强大的少样本学习(few-shot learning)能力，仅通过输入任务描述和少量示例，就能在翻译、问答、文本生成等任务上取得极具竞争力的表现  。</p>
<p>同年，Google推出了PaLM模型，参数规模达到5400亿，强调多步推理能力  。PaLM在多种复杂推理任务上表现出色，超过了人类在BIG-bench基准上的平均水平  。</p>
<p>2021年，Meta发布了LLaMA系列模型，包括7B、13B、33B和65B参数的不同变体，展示了开源大模型的潜力  。LLaMA在多种NLP任务上达到或接近闭源模型的性能，为研究者提供了重要的研究工具  。</p>
<h4 id="3-对齐与优化阶段2022-2023">3. 对齐与优化阶段(2022-2023)</h4>
<p>2022年，OpenAI发布了 ChatGPT 和 InstructGPT 模型，<strong>首次系统应用基于人类反馈的强化学习(RLHF)技术优化模型的指令遵循能力</strong>  。RLHF通过三阶段流程(监督微调、奖励模型训练、PPO优化)使模型输出更符合人类偏好，显著降低了幻觉和有害内容的生成概率  。</p>
<p>同年，Google推出了LaMDA模型，专注于对话应用，进一步提升了模型的对话能力  。LaMDA采用更高效的训练策略，能够在保持高性能的同时降低计算成本  。</p>
<p>2023年，Anthropic发布了Claude模型，强调安全对齐和推理能力。Claude采用不同的对齐方法，如通过对比人类和AI的思考过程来优化模型行为，为LLM的安全应用提供了新思路。</p>
<h4 id="4-多模态与专业化阶段2023-2025">4. 多模态与专业化阶段(2023-2025)</h4>
<p>2023年，OpenAI发布了GPT-4，<strong>首次将文本和图像的多模态信号整合到LLM中</strong>  。GPT-4的多模态能力使模型能够理解并生成图文结合的内容，大大扩展了应用场景  。</p>
<p>2024年，Claude 3系列发布，包括Claude 3.5 Haiku和Sonnet，以及2025年发布的Claude 3.7 Sonnet  。Claude 3.7引入&quot;标准+扩展&quot;双模式，用户可通过API控制&quot;思考预算&quot;，在速度、成本与准确性间灵活权衡  。这一创新使模型能够在不同场景下提供最佳性能。</p>
<p>2025年，LLM的发展呈现出两大趋势：一是多模态能力的深化，从文本+图像扩展到视频、3D生成  ；二是垂直领域的专业化，通过适配微调和技术融合，使模型更好地适应特定行业需求  。</p>
<p><strong>这一阶段的关键技术突破包括：</strong></p>
<ul>
<li>2022年：RLHF技术系统化应用，优化模型指令遵循能力</li>
<li>2023年：GPT-4多模态能力发布，整合文本和图像信号</li>
<li>2023年：LoRA(Low-Rank Adaptation)微调技术提出，显著提升微调效率</li>
<li>2024年：Claude 3.5系列发布，支持PDF解析和跨模态推理</li>
<li>2025年：Claude 3.7 Sonnet引入混合推理模式，支持动态计算资源分配</li>
</ul>
<h3 id="四-llm的训练方法演进">四、LLM的训练方法演进</h3>
<p>LLM的发展不仅体现在模型架构和参数规模上，其训练方法也经历了重要变革。<strong>从早期的简单预训练到如今的复杂多阶段训练流程，LLM的训练方法不断优化，以提高模型性能和降低训练成本</strong>  。</p>
<h4 id="1-预训练技术">1. 预训练技术</h4>
<p>预训练是LLM获取通用语言知识的基础阶段。早期的预训练目标主要是预测下一个单词，如GPT系列模型采用的自回归建模  。BERT则采用了掩码语言模型(MLM)和下一句预测(NSP)两个任务，使模型能够同时考虑单词的前后上下文  。</p>
<p><strong>预训练数据来源也经历了从封闭到开放的转变</strong>  。早期的模型主要使用书籍和特定网站数据，如GPT-1使用了Common Crawl的网页数据和书籍数据。随着模型规模的扩大，数据量也大幅增加，如GPT-3使用了570GB的文本数据  。如今，数据清洗和处理成为预训练的关键环节，如Data-Juicer等系统专门用于大规模文本数据的清洗和预处理  。</p>
<h4 id="2-微调技术">2. 微调技术</h4>
<p>微调是使预训练模型适应特定任务的关键步骤。早期的微调主要是全参数微调，即更新模型的所有参数  。然而，随着模型参数量的增加，全参数微调的成本也大幅提高。</p>
<p><strong>参数效率微调方法的出现显著降低了微调成本</strong>  。2022年，LoRA(Low-Rank Adaptation)技术提出，通过低秩矩阵分解仅更新少量参数，微调效率大幅提升  。2023年，AdaLoRA在LoRA基础上改进，能够自适应选择需要更新的参数层，进一步提升了微调效率  。2024年，LISA(Layerwise Importance Sampled Adam)策略通过分层重要性采样，随机激活少数中间层进行优化，平衡了性能与资源消耗  。</p>
<p>此外，检索增强生成(RAG)技术也被广泛应用于提升LLM的实时性和准确性  。RAG通过结合外部知识库和LLM的能力，使模型能够生成更精确、更即时的回答，有效减少幻觉问题  。</p>
<h4 id="3-对齐技术">3. 对齐技术</h4>
<p>随着LLM能力的增强，如何使模型输出符合人类价值观成为重要问题。<strong>RLHF(基于人类反馈的强化学习)技术的出现为模型对齐提供了有效解决方案</strong>  。</p>
<h2 id=""></h2>
<p>RLHF的三阶段流程包括：监督微调(SFT)、奖励模型(RM)训练和PPO优化  。SFT阶段使模型能够理解指令并生成初步回答；RM阶段通过人工对SFT输出排序，训练能够评估模型输出质量的奖励模型；PPO阶段则使用近端策略优化算法，使模型生成的输出尽可能获得更高的奖励分数，从而更符合人类偏好  。</p>
<p><strong>RLHF技术的改进方向包括：</strong></p>
<ul>
<li>FINE-GRAINED RLHF：将回答拆解为以句子为单位，分别评估事实准确性、相关性和信息完整性</li>
<li>RAFT/RRHF：通过RM对生成模型的输出排序，再使用类似SFT的技术训练选定的样本，减少对PPO的依赖</li>
<li>DPO(Direct Preference Optimization)：直接优化偏好而非依赖RL阶段，大幅减少计算量</li>
</ul>
<h3 id="五-llm的未来发展趋势">五、LLM的未来发展趋势</h3>
<p>展望未来，LLM的发展将沿着多模态深化、垂直领域专业化、轻量化与效率提升、技术融合以及伦理治理等方向演进。</p>
<h4 id="1-多模态能力深化">1. 多模态能力深化</h4>
<p><strong>从文本到图像，再到视频和3D生成，LLM的多模态能力将持续深化</strong>  。目前，GPT-4和Claude 3.5已支持图文结合的内容生成，但视频和3D生成仍处于初级阶段。未来，通过更高效的跨模态注意力机制和数据处理技术，LLM将能够处理更复杂的多模态数据，如视频理解、3D场景生成等  。</p>
<h4 id="2-垂直领域专业化">2. 垂直领域专业化</h4>
<p><strong>通用大模型将向垂直领域专业化发展</strong>  ，通过适配微调和技术融合，使模型更好地适应特定行业需求。</p>
<h2 id="-2"></h2>
<p>例如，在医疗领域，LLM可以结合医学知识图谱和专业数据库，提供更准确的诊断建议和治疗方案；在法律领域，LLM可以学习法律条文和案例，辅助法律研究和文书起草；在金融领域，LLM可以分析市场数据和风险因素，提供投资建议和风险管理方案  。</p>
<h4 id="3-轻量化与效率提升">3. 轻量化与效率提升</h4>
<p><strong>随着模型规模的扩大，轻量化和效率提升将成为重要研究方向</strong>  。混合专家(MoE)架构、参数效率微调方法和专用硬件加速等技术将共同推动LLM的轻量化发展  。例如，Claude 3.7的混合推理模式允许用户根据需求在速度、成本与准确性间灵活权衡  ；专用AI芯片如NVIDIA Hopper将为端侧LLM轻量化提供硬件支持  。</p>
<h4 id="4-量子计算与llm结合">4. 量子计算与LLM结合</h4>
<p><strong>量子计算与LLM的结合将开启新的可能性</strong>。</p>
<p>虽然目前仍处于理论探索阶段，但已有研究表明，LLM可以辅助量子电路设计，如在变分量子特征求解器(VQE)中作为控制器进行经典优化 。同时，量子机器学习框架如MAQA通过量子态制备提升计算效率，为LLM的训练和推理提供新的计算范式  。</p>
<h4 id="5-实时学习与知识更新">5. 实时学习与知识更新</h4>
<p><strong>解决LLM的知识过时问题将成为关键挑战</strong>  。目前，LLM主要依赖预训练和RAG技术来获取最新知识，但这一方法存在检索速度和准确性上的局限性。未来，通过增量学习、在线学习和自适应知识更新等技术，LLM将能够实时吸纳新知识，减少对模型本身已有知识的依赖  。</p>
<h4 id="6-伦理治理与安全应用">6. 伦理治理与安全应用</h4>
<p><strong>随着LLM能力的增强，其伦理治理和安全应用将受到更多关注</strong>  。目前，LLM仍存在非真实性和偏见性输出的问题，如编造学术文献和链接。</p>
<p>未来，通过动态偏见检测、可解释性增强和跨法域适配等技术，LLM的安全性和可靠性将得到提升。同时，多维度评估框架如HELM和IN结构调整也将帮助更好地评估和改进模型性能  。</p>
<h3 id="六-llm发展史的时间线">六、LLM发展史的时间线</h3>
<table>
<thead>
<tr>
<th>年份</th>
<th>关键技术/模型</th>
<th>参数规模</th>
<th>主要贡献</th>
</tr>
</thead>
<tbody>
<tr>
<td>2013</td>
<td>Word2Vec</td>
<td>-</td>
<td>首个分布式词向量模型</td>
</tr>
<tr>
<td>2014</td>
<td>Seq2Seq</td>
<td>-</td>
<td>基于RNN的序列到序列模型</td>
</tr>
<tr>
<td>2015</td>
<td>注意力机制</td>
<td>-</td>
<td>解决RNN的长距离依赖问题</td>
</tr>
<tr>
<td>2017</td>
<td>Transformer</td>
<td>-</td>
<td>引入自注意力机制，实现并行计算</td>
</tr>
<tr>
<td>2018</td>
<td>BERT</td>
<td>3.5B/4B</td>
<td>首个双向Transformer预训练模型</td>
</tr>
<tr>
<td>2018</td>
<td>GPT-1</td>
<td>110M</td>
<td>预训练+微调范式</td>
</tr>
<tr>
<td>2019</td>
<td>GPT-2</td>
<td>1.5B</td>
<td>展示生成文本的可控性挑战</td>
</tr>
<tr>
<td>2019</td>
<td>Megatron-LM</td>
<td>83B</td>
<td>验证模型规模扩展的可行性</td>
</tr>
<tr>
<td>2019</td>
<td>T5</td>
<td>11B/3B</td>
<td>统一文本任务为&quot;文本到文本&quot;格式</td>
</tr>
<tr>
<td>2020</td>
<td>GPT-3</td>
<td>175B</td>
<td>验证少样本学习能力</td>
</tr>
<tr>
<td>2020</td>
<td>PaLM</td>
<td>540B</td>
<td>强调多步推理能力</td>
</tr>
<tr>
<td>2021</td>
<td>LLaMA</td>
<td>7B-65B</td>
<td>开源大模型系列</td>
</tr>
<tr>
<td>2022</td>
<td>InstructGPT</td>
<td>175B</td>
<td>首次系统应用RLHF技术</td>
</tr>
<tr>
<td>2022</td>
<td>ChatGPT</td>
<td>-</td>
<td>人机对话能力突破</td>
</tr>
<tr>
<td>2023</td>
<td>GPT-4</td>
<td>1.8T</td>
<td>多模态能力整合</td>
</tr>
<tr>
<td>2023</td>
<td>Claude 1</td>
<td>-</td>
<td>安全对齐和推理能力</td>
</tr>
<tr>
<td>2023</td>
<td>LoRA</td>
<td>-</td>
<td>参数效率微调技术</td>
</tr>
<tr>
<td>2024</td>
<td>Claude 3.5</td>
<td>-</td>
<td>支持PDF解析和跨模态推理</td>
</tr>
<tr>
<td>2025</td>
<td>Claude 3.7 Sonnet</td>
<td>-</td>
<td>混合推理模式，动态计算资源分配</td>
</tr>
</tbody>
</table>
<h2 id="-3"></h2>
<h3 id="七-llm对社会和行业的影响">七、LLM对社会和行业的影响</h3>
<p>LLM的发展不仅推动了技术进步，也对社会和行业产生了深远影响。<strong>在内容创作领域，LLM大幅提高了内容生成效率，降低了创作门槛</strong>  ；在客户服务领域，LLM驱动的智能客服能够提供24/7的服务，显著提升用户体验  ；在教育领域，LLM可以作为个性化学习助手，帮助学生解决问题和获取知识  ；在医疗领域，LLM可以辅助诊断和治疗方案制定，提高医疗效率  ；在法律领域，LLM可以处理法律文档和研究案例，帮助律师提高工作效率  。</p>
<p>然而，LLM也带来了新的挑战和风险。<strong>模型的非真实性和偏见性输出可能导致虚假信息传播和社会不平等</strong>  ；模型的实时自主学习能力欠缺使得知识更新滞后；模型的强依赖数据集质量和数量也限制了其在特定领域的应用  。未来，随着LLM技术的成熟和应用场景的扩展，这些挑战和风险也将得到更多关注和解决方案。</p>
<h2 id="-4"></h2>
<h3 id="八-结语">八、结语</h3>
<p>从统计语言模型到基于Transformer的大型语言模型，LLM的发展史是一部技术不断突破、能力不断提升的历程。<strong>随着参数规模的扩大、训练方法的优化和多模态能力的深化，LLM正逐步向通用人工智能方向演进</strong>  。然而，这一演进过程也伴随着技术局限和安全风险，需要研究者、开发者和政策制定者共同努力，推动LLM技术的健康发展和广泛应用。</p>
<p>未来，LLM的发展将更加注重轻量化、专业化和安全性，通过与图神经网络、量子计算等技术的融合，进一步拓展其应用边界和能力上限  。<strong>在这一过程中，LLM不仅将重塑人机交互方式，也将成为推动各行业数字化转型和智能化升级的重要力量</strong> 。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从零开始学 AI 总集篇]]></title>
        <id>https://panson.top/post/ai/</id>
        <link href="https://panson.top/post/ai/">
        </link>
        <updated>2025-03-21T08:28:31.000Z</updated>
        <summary type="html"><![CDATA[<p><em>想多了解一点这个快速发展的世界，学习一下 AI 相关的知识。</em></p>
<h2 id="一-工具篇">一、工具篇</h2>
<p>本地部署试过 Ollama + DeepSeek R1 32 b，19 年的英特尔芯片已经带不动了。</p>
]]></summary>
        <content type="html"><![CDATA[<p><em>想多了解一点这个快速发展的世界，学习一下 AI 相关的知识。</em></p>
<h2 id="一-工具篇">一、工具篇</h2>
<p>本地部署试过 Ollama + DeepSeek R1 32 b，19 年的英特尔芯片已经带不动了。</p>
<!-- more -->
<p>目前主要用的是 Cherry Studio + 字节方舟的 DeepSeek R1，主要是因为当时领了几十块钱的券~<br>
但是腾讯元宝真的很方便，而且免费。<br>
Web 端的话各种官网混用：腾讯元宝 、ChatGpt、Claude、通义千问。<br>
编辑器的话，用的是Trae，之前用 Trae + Hugo 搭了一个摄影小站：</p>
<ul>
<li>www.timelesslens.site</li>
</ul>
<h2 id="二-ai-名词">二、AI 名词</h2>
<h3 id="21-rag">2.1 RAG</h3>
<p>RAG 的全称是：Retrieval-Augmented Generation，翻译成中文是：检索增强生成。</p>
<p>简而言之就是让大语言模型（比如 ChatGPT）在“生成答案”之前，先去找资料（检索）来增强它的知识，再用这些资料来生成更准确的回答。</p>
<h4 id="211-为什么需要rag">2.1.1 为什么需要RAG？</h4>
<p>因为对于很多大语言模型来说，他的知识是基于历史数据训练出来的，比如GPT-4是截止到2023年的数据，而在这之后发生的所有的新的事件，新的数据，他都是不知道的，那么他的回答就会有这部分的局限性。</p>
<p>还有就是，很多大模型是基于公开的资料训练出来的，而很多私域的信息他是没有学习过的，而很多知识是私有的知识，这就需要通过资料的方式增强他原来不熟悉的知识。</p>
<p>所以，有了RAG之后，就可以基于自己的知识构建自己的知识库，这样就能做到知识的更新和迭代，也能弥补大模型不知道一些特性领域的专业知识的不足。这样就能让大模型的回答更加的准确， 减少幻觉的发生。</p>
<h4 id="212-如何构建一个rag">2.1.2 如何构建一个RAG？</h4>
<p>1、前置准备</p>
<p>首先我们需要做数据准备，把你要用的资料收集好，比如：公司内部文档（PDF、Word、Markdown）、FAQ列表、产品手册等，然后清洗这些数据，比如去掉无关信息、切分成合理的小段。</p>
<p>然后把每一小段文本用Embedding模型转成向量，把这些向量存到向量数据库里，比如FAISS、Milvus等。</p>
<p>2、检索查询</p>
<p>当用户提问时，先用相同的Embedding模型把问题也转成向量。然后在向量数据库里用向量相似度搜索，找出最相关的几段资料（比如Top 5）。这些找到的内容就是上下文增强材料。</p>
<p>3、生成回答</p>
<p>紧接着，就可以把用户的问题 + 检索到的资料一起，作为Prompt发给大语言模型（LLM）。 这样可以保证模型只在资料范围内生成答案，降低幻觉。</p>
<h3 id="22-mcp">2.2 MCP</h3>
<p>MCP 的全称是 Model Context Protocol，下面是官网上的解释：</p>
<blockquote>
<p>MCP is an open protocol that standardizes how applications provide context to LLMs. Think of MCP like a USB-C port for AI applications. Just as USB-C provides a standardized way to connect your devices to various peripherals and accessories, MCP provides a standardized way to connect AI models to different data sources and tools.</p>
</blockquote>
<p>MCP全称是模型上下文协议（Model Context Protocol），由Anthropic在2024年11月推出。它本质上是大模型与外部世界连接的标准化接口，就像给大模型装了个万能插座。</p>
<p>MCP中有三个核心组件</p>
<ul>
<li>MCP Hosts：如Claude Desktop或IDE（比如Cursor），作为AI应用的入口，发起数据请求。</li>
<li>MCP Servers：轻量级服务，负责对接具体数据源或工具（如GitHub API、本地文件系统），提供标准化接口。（一般是别人开发好的，你要用的工具）</li>
<li>MCP Clients：协议客户端，维护与服务器的连接并转发请求。</li>
</ul>
<p>有了MCP之后，当用户提出一个问题时，就是大致下面的流程：</p>
<ul>
<li>客户端（Claude Desktop / Cursor）将你的问题发送给大模型（如Claude）。</li>
<li>Claude 分析可用的工具，并决定使用哪一个（或多个）。</li>
<li>客户端通过 MCP Server 执行所选的工具。</li>
<li>工具的执行结果被送回给 Claude。</li>
<li>Claude 结合执行结果构造最终的 prompt 并生成自然语言的回应。</li>
<li>回应最终展示给用户</li>
</ul>
<h3 id="23-提示词工程">2.3 提示词工程</h3>
<p><strong>Temperature：</strong> 简单来说，temperature 的参数值越小，模型就会返回越确定的一个结果。如果调高该参数值，大语言模型可能会返回更随机的结果，也就是说这可能会带来更多样化或更具创造性的产出。（调小temperature）实质上，你是在增加其他可能的 token 的权重。在实际应用方面，对于质量保障（QA）等任务，我们可以设置更低的 temperature 值，以促使模型基于事实返回更真实和简洁的结果。 对于诗歌生成或其他创造性任务，适度地调高 temperature 参数值可能会更好。</p>
<p><strong>Top_p：</strong> 同样，使用 top_p（与 temperature 一起称为核采样（nucleus sampling）的技术），可以用来控制模型返回结果的确定性。如果你需要准确和事实的答案，就把参数值调低。如果你在寻找更多样化的响应，可以将其值调高点。</p>
<p>使用Top_P意味着只有词元集合（tokens）中包含top_p概率质量的才会被考虑用于响应，因此较低的Top_p值会选择最有信心的响应。这意味着较高的top_p值将使模型考虑更多可能的词语，包括不太可能的词语，从而导致更多样化的输出。</p>
<p>一般建议是改变 Temperature 和 Top P 其中一个参数就行，<strong>不用两个都调整</strong>。</p>
<p><strong>Max Length：</strong>  可以通过调整 max length 来控制大模型生成的 token 数。指定 Max Length 有助于防止大模型生成冗长或不相关的响应并控制成本。</p>
<p><strong>Stop Sequences：</strong>  stop sequence 是一个字符串，可以阻止模型生成 token，指定 stop sequences 是控制大模型响应长度和结构的另一种方法。例如，您可以通过添加 “11” 作为 stop sequence 来告诉模型生成不超过 10 个项的列表。</p>
<p><strong>Frequency Penalty：</strong> frequency penalty 是对下一个生成的 token 进行惩罚，这个惩罚和 token 在响应和提示中已出现的次数成比例， frequency penalty 越高，某个词再次出现的可能性就越小，这个设置通过给 重复数量多的 Token 设置更高的惩罚来减少响应中单词的重复。</p>
<p><strong>Presence Penalty：</strong> presence penalty 也是对重复的 token 施加惩罚，但与 frequency penalty 不同的是，惩罚对于所有重复 token 都是相同的。出现两次的 token 和出现 10 次的 token 会受到相同的惩罚。 此设置可防止模型在响应中过于频繁地生成重复的词。 如果您希望模型生成多样化或创造性的文本，可以设置更高的 presence penalty，如果您希望模型生成更专注的内容，您可以设置更低的 presence penalty。</p>
<p>与 temperature 和 top_p 一样，一般建议是改变 frequency penalty 和 presence penalty 其中一个参数就行，不要同时调整两个。</p>
]]></content>
    </entry>
</feed>